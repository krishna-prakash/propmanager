// Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.

package prisma

import (
	"context"
	"errors"

	"github.com/prisma/prisma-client-lib-go"

	"github.com/machinebox/graphql"
)

var ErrNoResult = errors.New("query returned no result")

func Str(v string) *string { return &v }
func Int32(v int32) *int32 { return &v }
func Bool(v bool) *bool    { return &v }

type BatchPayloadExec struct {
	exec *prisma.BatchPayloadExec
}

func (exec *BatchPayloadExec) Exec(ctx context.Context) (BatchPayload, error) {
	bp, err := exec.exec.Exec(ctx)
	return BatchPayload(bp), err
}

type BatchPayload struct {
	Count int64 `json:"count"`
}

type Aggregate struct {
	Count int64 `json:"count"`
}

type Client struct {
	Client *prisma.Client
}

type Options struct {
	Endpoint string
	Secret   string
}

func New(options *Options, opts ...graphql.ClientOption) *Client {
	endpoint := DefaultEndpoint
	secret := Secret
	if options != nil {
		endpoint = options.Endpoint
		secret = options.Secret
	}
	return &Client{
		Client: prisma.New(endpoint, secret, opts...),
	}
}

func (client *Client) GraphQL(ctx context.Context, query string, variables map[string]interface{}) (map[string]interface{}, error) {
	return client.Client.GraphQL(ctx, query, variables)
}

var DefaultEndpoint = "http://localhost:4466"
var Secret = ""

func (client *Client) Agent(params AgentWhereUniqueInput) *AgentExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"AgentWhereUniqueInput!", "Agent"},
		"agent",
		[]string{"id", "businessService", "title", "firstName", "lastName", "displayName", "email", "password", "mobile", "fax", "address1", "address2", "postcode", "country", "website"})

	return &AgentExec{ret}
}

type AgentsParams struct {
	Where   *AgentWhereInput   `json:"where,omitempty"`
	OrderBy *AgentOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

func (client *Client) Agents(params *AgentsParams) *AgentExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"AgentWhereInput", "AgentOrderByInput", "Agent"},
		"agents",
		[]string{"id", "businessService", "title", "firstName", "lastName", "displayName", "email", "password", "mobile", "fax", "address1", "address2", "postcode", "country", "website"})

	return &AgentExecArray{ret}
}

type AgentsConnectionParams struct {
	Where   *AgentWhereInput   `json:"where,omitempty"`
	OrderBy *AgentOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

func (client *Client) AgentsConnection(params *AgentsConnectionParams) AgentConnectionExec {
	panic("not implemented")
}

func (client *Client) Landlord(params LandlordWhereUniqueInput) *LandlordExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"LandlordWhereUniqueInput!", "Landlord"},
		"landlord",
		[]string{"id", "fullName", "email", "password", "mobile", "dob", "occupation", "address1", "address2", "postcode", "country"})

	return &LandlordExec{ret}
}

type LandlordsParams struct {
	Where   *LandlordWhereInput   `json:"where,omitempty"`
	OrderBy *LandlordOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

func (client *Client) Landlords(params *LandlordsParams) *LandlordExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"LandlordWhereInput", "LandlordOrderByInput", "Landlord"},
		"landlords",
		[]string{"id", "fullName", "email", "password", "mobile", "dob", "occupation", "address1", "address2", "postcode", "country"})

	return &LandlordExecArray{ret}
}

type LandlordsConnectionParams struct {
	Where   *LandlordWhereInput   `json:"where,omitempty"`
	OrderBy *LandlordOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

func (client *Client) LandlordsConnection(params *LandlordsConnectionParams) LandlordConnectionExec {
	panic("not implemented")
}

func (client *Client) Property(params PropertyWhereUniqueInput) *PropertyExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"PropertyWhereUniqueInput!", "Property"},
		"property",
		[]string{"id", "address1", "address2", "postcode", "city", "country", "percentageofownership", "purchaseprice", "currentprice", "mortgageAmount", "mortgageInterestRate", "annualRentalIncome", "currency"})

	return &PropertyExec{ret}
}

type PropertiesParams struct {
	Where   *PropertyWhereInput   `json:"where,omitempty"`
	OrderBy *PropertyOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

func (client *Client) Properties(params *PropertiesParams) *PropertyExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PropertyWhereInput", "PropertyOrderByInput", "Property"},
		"properties",
		[]string{"id", "address1", "address2", "postcode", "city", "country", "percentageofownership", "purchaseprice", "currentprice", "mortgageAmount", "mortgageInterestRate", "annualRentalIncome", "currency"})

	return &PropertyExecArray{ret}
}

type PropertiesConnectionParams struct {
	Where   *PropertyWhereInput   `json:"where,omitempty"`
	OrderBy *PropertyOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

func (client *Client) PropertiesConnection(params *PropertiesConnectionParams) PropertyConnectionExec {
	panic("not implemented")
}

func (client *Client) PropertyStatus(params PropertyStatusWhereUniqueInput) *PropertyStatusExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"PropertyStatusWhereUniqueInput!", "PropertyStatus"},
		"propertyStatus",
		[]string{"id", "status"})

	return &PropertyStatusExec{ret}
}

type PropertyStatusesParams struct {
	Where   *PropertyStatusWhereInput   `json:"where,omitempty"`
	OrderBy *PropertyStatusOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                      `json:"skip,omitempty"`
	After   *string                     `json:"after,omitempty"`
	Before  *string                     `json:"before,omitempty"`
	First   *int32                      `json:"first,omitempty"`
	Last    *int32                      `json:"last,omitempty"`
}

func (client *Client) PropertyStatuses(params *PropertyStatusesParams) *PropertyStatusExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PropertyStatusWhereInput", "PropertyStatusOrderByInput", "PropertyStatus"},
		"propertyStatuses",
		[]string{"id", "status"})

	return &PropertyStatusExecArray{ret}
}

type PropertyStatusesConnectionParams struct {
	Where   *PropertyStatusWhereInput   `json:"where,omitempty"`
	OrderBy *PropertyStatusOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                      `json:"skip,omitempty"`
	After   *string                     `json:"after,omitempty"`
	Before  *string                     `json:"before,omitempty"`
	First   *int32                      `json:"first,omitempty"`
	Last    *int32                      `json:"last,omitempty"`
}

func (client *Client) PropertyStatusesConnection(params *PropertyStatusesConnectionParams) PropertyStatusConnectionExec {
	panic("not implemented")
}

func (client *Client) PropertyType(params PropertyTypeWhereUniqueInput) *PropertyTypeExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"PropertyTypeWhereUniqueInput!", "PropertyType"},
		"propertyType",
		[]string{"id", "type"})

	return &PropertyTypeExec{ret}
}

type PropertyTypesParams struct {
	Where   *PropertyTypeWhereInput   `json:"where,omitempty"`
	OrderBy *PropertyTypeOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

func (client *Client) PropertyTypes(params *PropertyTypesParams) *PropertyTypeExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PropertyTypeWhereInput", "PropertyTypeOrderByInput", "PropertyType"},
		"propertyTypes",
		[]string{"id", "type"})

	return &PropertyTypeExecArray{ret}
}

type PropertyTypesConnectionParams struct {
	Where   *PropertyTypeWhereInput   `json:"where,omitempty"`
	OrderBy *PropertyTypeOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

func (client *Client) PropertyTypesConnection(params *PropertyTypesConnectionParams) PropertyTypeConnectionExec {
	panic("not implemented")
}

func (client *Client) Tenant(params TenantWhereUniqueInput) *TenantExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"TenantWhereUniqueInput!", "Tenant"},
		"tenant",
		[]string{"id", "title", "firstName", "middleName", "lastName", "displayName", "personalEmail", "workEmail", "homenumber", "mobilenumber", "rentInterval", "day", "startDate", "endDate", "notes"})

	return &TenantExec{ret}
}

type TenantsParams struct {
	Where   *TenantWhereInput   `json:"where,omitempty"`
	OrderBy *TenantOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32              `json:"skip,omitempty"`
	After   *string             `json:"after,omitempty"`
	Before  *string             `json:"before,omitempty"`
	First   *int32              `json:"first,omitempty"`
	Last    *int32              `json:"last,omitempty"`
}

func (client *Client) Tenants(params *TenantsParams) *TenantExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"TenantWhereInput", "TenantOrderByInput", "Tenant"},
		"tenants",
		[]string{"id", "title", "firstName", "middleName", "lastName", "displayName", "personalEmail", "workEmail", "homenumber", "mobilenumber", "rentInterval", "day", "startDate", "endDate", "notes"})

	return &TenantExecArray{ret}
}

type TenantsConnectionParams struct {
	Where   *TenantWhereInput   `json:"where,omitempty"`
	OrderBy *TenantOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32              `json:"skip,omitempty"`
	After   *string             `json:"after,omitempty"`
	Before  *string             `json:"before,omitempty"`
	First   *int32              `json:"first,omitempty"`
	Last    *int32              `json:"last,omitempty"`
}

func (client *Client) TenantsConnection(params *TenantsConnectionParams) TenantConnectionExec {
	panic("not implemented")
}

func (client *Client) TypeOfLet(params TypeOfLetWhereUniqueInput) *TypeOfLetExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"TypeOfLetWhereUniqueInput!", "TypeOfLet"},
		"typeOfLet",
		[]string{"id", "name"})

	return &TypeOfLetExec{ret}
}

type TypeOfLetsParams struct {
	Where   *TypeOfLetWhereInput   `json:"where,omitempty"`
	OrderBy *TypeOfLetOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                 `json:"skip,omitempty"`
	After   *string                `json:"after,omitempty"`
	Before  *string                `json:"before,omitempty"`
	First   *int32                 `json:"first,omitempty"`
	Last    *int32                 `json:"last,omitempty"`
}

func (client *Client) TypeOfLets(params *TypeOfLetsParams) *TypeOfLetExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"TypeOfLetWhereInput", "TypeOfLetOrderByInput", "TypeOfLet"},
		"typeOfLets",
		[]string{"id", "name"})

	return &TypeOfLetExecArray{ret}
}

type TypeOfLetsConnectionParams struct {
	Where   *TypeOfLetWhereInput   `json:"where,omitempty"`
	OrderBy *TypeOfLetOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                 `json:"skip,omitempty"`
	After   *string                `json:"after,omitempty"`
	Before  *string                `json:"before,omitempty"`
	First   *int32                 `json:"first,omitempty"`
	Last    *int32                 `json:"last,omitempty"`
}

func (client *Client) TypeOfLetsConnection(params *TypeOfLetsConnectionParams) TypeOfLetConnectionExec {
	panic("not implemented")
}

func (client *Client) CreateAgent(params AgentCreateInput) *AgentExec {
	ret := client.Client.Create(
		params,
		[2]string{"AgentCreateInput!", "Agent"},
		"createAgent",
		[]string{"id", "businessService", "title", "firstName", "lastName", "displayName", "email", "password", "mobile", "fax", "address1", "address2", "postcode", "country", "website"})

	return &AgentExec{ret}
}

type AgentUpdateParams struct {
	Data  AgentUpdateInput      `json:"data"`
	Where AgentWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateAgent(params AgentUpdateParams) *AgentExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"AgentUpdateInput!", "AgentWhereUniqueInput!", "Agent"},
		"updateAgent",
		[]string{"id", "businessService", "title", "firstName", "lastName", "displayName", "email", "password", "mobile", "fax", "address1", "address2", "postcode", "country", "website"})

	return &AgentExec{ret}
}

type AgentUpdateManyParams struct {
	Data  AgentUpdateManyMutationInput `json:"data"`
	Where *AgentWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyAgents(params AgentUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"AgentUpdateManyMutationInput!", "AgentWhereInput"},
		"updateManyAgents")
	return &BatchPayloadExec{exec}
}

type AgentUpsertParams struct {
	Where  AgentWhereUniqueInput `json:"where"`
	Create AgentCreateInput      `json:"create"`
	Update AgentUpdateInput      `json:"update"`
}

func (client *Client) UpsertAgent(params AgentUpsertParams) *AgentExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"AgentWhereUniqueInput!", "AgentCreateInput!", "AgentUpdateInput!", "Agent"},
		"upsertAgent",
		[]string{"id", "businessService", "title", "firstName", "lastName", "displayName", "email", "password", "mobile", "fax", "address1", "address2", "postcode", "country", "website"})

	return &AgentExec{ret}
}

func (client *Client) DeleteAgent(params AgentWhereUniqueInput) *AgentExec {
	ret := client.Client.Delete(
		params,
		[2]string{"AgentWhereUniqueInput!", "Agent"},
		"deleteAgent",
		[]string{"id", "businessService", "title", "firstName", "lastName", "displayName", "email", "password", "mobile", "fax", "address1", "address2", "postcode", "country", "website"})

	return &AgentExec{ret}
}

func (client *Client) DeleteManyAgents(params *AgentWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "AgentWhereInput", "deleteManyAgents")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateLandlord(params LandlordCreateInput) *LandlordExec {
	ret := client.Client.Create(
		params,
		[2]string{"LandlordCreateInput!", "Landlord"},
		"createLandlord",
		[]string{"id", "fullName", "email", "password", "mobile", "dob", "occupation", "address1", "address2", "postcode", "country"})

	return &LandlordExec{ret}
}

type LandlordUpdateParams struct {
	Data  LandlordUpdateInput      `json:"data"`
	Where LandlordWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateLandlord(params LandlordUpdateParams) *LandlordExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"LandlordUpdateInput!", "LandlordWhereUniqueInput!", "Landlord"},
		"updateLandlord",
		[]string{"id", "fullName", "email", "password", "mobile", "dob", "occupation", "address1", "address2", "postcode", "country"})

	return &LandlordExec{ret}
}

type LandlordUpdateManyParams struct {
	Data  LandlordUpdateManyMutationInput `json:"data"`
	Where *LandlordWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyLandlords(params LandlordUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"LandlordUpdateManyMutationInput!", "LandlordWhereInput"},
		"updateManyLandlords")
	return &BatchPayloadExec{exec}
}

type LandlordUpsertParams struct {
	Where  LandlordWhereUniqueInput `json:"where"`
	Create LandlordCreateInput      `json:"create"`
	Update LandlordUpdateInput      `json:"update"`
}

func (client *Client) UpsertLandlord(params LandlordUpsertParams) *LandlordExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"LandlordWhereUniqueInput!", "LandlordCreateInput!", "LandlordUpdateInput!", "Landlord"},
		"upsertLandlord",
		[]string{"id", "fullName", "email", "password", "mobile", "dob", "occupation", "address1", "address2", "postcode", "country"})

	return &LandlordExec{ret}
}

func (client *Client) DeleteLandlord(params LandlordWhereUniqueInput) *LandlordExec {
	ret := client.Client.Delete(
		params,
		[2]string{"LandlordWhereUniqueInput!", "Landlord"},
		"deleteLandlord",
		[]string{"id", "fullName", "email", "password", "mobile", "dob", "occupation", "address1", "address2", "postcode", "country"})

	return &LandlordExec{ret}
}

func (client *Client) DeleteManyLandlords(params *LandlordWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "LandlordWhereInput", "deleteManyLandlords")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateProperty(params PropertyCreateInput) *PropertyExec {
	ret := client.Client.Create(
		params,
		[2]string{"PropertyCreateInput!", "Property"},
		"createProperty",
		[]string{"id", "address1", "address2", "postcode", "city", "country", "percentageofownership", "purchaseprice", "currentprice", "mortgageAmount", "mortgageInterestRate", "annualRentalIncome", "currency"})

	return &PropertyExec{ret}
}

type PropertyUpdateParams struct {
	Data  PropertyUpdateInput      `json:"data"`
	Where PropertyWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateProperty(params PropertyUpdateParams) *PropertyExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"PropertyUpdateInput!", "PropertyWhereUniqueInput!", "Property"},
		"updateProperty",
		[]string{"id", "address1", "address2", "postcode", "city", "country", "percentageofownership", "purchaseprice", "currentprice", "mortgageAmount", "mortgageInterestRate", "annualRentalIncome", "currency"})

	return &PropertyExec{ret}
}

type PropertyUpdateManyParams struct {
	Data  PropertyUpdateManyMutationInput `json:"data"`
	Where *PropertyWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyProperties(params PropertyUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"PropertyUpdateManyMutationInput!", "PropertyWhereInput"},
		"updateManyProperties")
	return &BatchPayloadExec{exec}
}

type PropertyUpsertParams struct {
	Where  PropertyWhereUniqueInput `json:"where"`
	Create PropertyCreateInput      `json:"create"`
	Update PropertyUpdateInput      `json:"update"`
}

func (client *Client) UpsertProperty(params PropertyUpsertParams) *PropertyExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"PropertyWhereUniqueInput!", "PropertyCreateInput!", "PropertyUpdateInput!", "Property"},
		"upsertProperty",
		[]string{"id", "address1", "address2", "postcode", "city", "country", "percentageofownership", "purchaseprice", "currentprice", "mortgageAmount", "mortgageInterestRate", "annualRentalIncome", "currency"})

	return &PropertyExec{ret}
}

func (client *Client) DeleteProperty(params PropertyWhereUniqueInput) *PropertyExec {
	ret := client.Client.Delete(
		params,
		[2]string{"PropertyWhereUniqueInput!", "Property"},
		"deleteProperty",
		[]string{"id", "address1", "address2", "postcode", "city", "country", "percentageofownership", "purchaseprice", "currentprice", "mortgageAmount", "mortgageInterestRate", "annualRentalIncome", "currency"})

	return &PropertyExec{ret}
}

func (client *Client) DeleteManyProperties(params *PropertyWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "PropertyWhereInput", "deleteManyProperties")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreatePropertyStatus(params PropertyStatusCreateInput) *PropertyStatusExec {
	ret := client.Client.Create(
		params,
		[2]string{"PropertyStatusCreateInput!", "PropertyStatus"},
		"createPropertyStatus",
		[]string{"id", "status"})

	return &PropertyStatusExec{ret}
}

type PropertyStatusUpdateParams struct {
	Data  PropertyStatusUpdateInput      `json:"data"`
	Where PropertyStatusWhereUniqueInput `json:"where"`
}

func (client *Client) UpdatePropertyStatus(params PropertyStatusUpdateParams) *PropertyStatusExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"PropertyStatusUpdateInput!", "PropertyStatusWhereUniqueInput!", "PropertyStatus"},
		"updatePropertyStatus",
		[]string{"id", "status"})

	return &PropertyStatusExec{ret}
}

type PropertyStatusUpdateManyParams struct {
	Data  PropertyStatusUpdateManyMutationInput `json:"data"`
	Where *PropertyStatusWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyPropertyStatuses(params PropertyStatusUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"PropertyStatusUpdateManyMutationInput!", "PropertyStatusWhereInput"},
		"updateManyPropertyStatuses")
	return &BatchPayloadExec{exec}
}

type PropertyStatusUpsertParams struct {
	Where  PropertyStatusWhereUniqueInput `json:"where"`
	Create PropertyStatusCreateInput      `json:"create"`
	Update PropertyStatusUpdateInput      `json:"update"`
}

func (client *Client) UpsertPropertyStatus(params PropertyStatusUpsertParams) *PropertyStatusExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"PropertyStatusWhereUniqueInput!", "PropertyStatusCreateInput!", "PropertyStatusUpdateInput!", "PropertyStatus"},
		"upsertPropertyStatus",
		[]string{"id", "status"})

	return &PropertyStatusExec{ret}
}

func (client *Client) DeletePropertyStatus(params PropertyStatusWhereUniqueInput) *PropertyStatusExec {
	ret := client.Client.Delete(
		params,
		[2]string{"PropertyStatusWhereUniqueInput!", "PropertyStatus"},
		"deletePropertyStatus",
		[]string{"id", "status"})

	return &PropertyStatusExec{ret}
}

func (client *Client) DeleteManyPropertyStatuses(params *PropertyStatusWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "PropertyStatusWhereInput", "deleteManyPropertyStatuses")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreatePropertyType(params PropertyTypeCreateInput) *PropertyTypeExec {
	ret := client.Client.Create(
		params,
		[2]string{"PropertyTypeCreateInput!", "PropertyType"},
		"createPropertyType",
		[]string{"id", "type"})

	return &PropertyTypeExec{ret}
}

type PropertyTypeUpdateParams struct {
	Data  PropertyTypeUpdateInput      `json:"data"`
	Where PropertyTypeWhereUniqueInput `json:"where"`
}

func (client *Client) UpdatePropertyType(params PropertyTypeUpdateParams) *PropertyTypeExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"PropertyTypeUpdateInput!", "PropertyTypeWhereUniqueInput!", "PropertyType"},
		"updatePropertyType",
		[]string{"id", "type"})

	return &PropertyTypeExec{ret}
}

type PropertyTypeUpdateManyParams struct {
	Data  PropertyTypeUpdateManyMutationInput `json:"data"`
	Where *PropertyTypeWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyPropertyTypes(params PropertyTypeUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"PropertyTypeUpdateManyMutationInput!", "PropertyTypeWhereInput"},
		"updateManyPropertyTypes")
	return &BatchPayloadExec{exec}
}

type PropertyTypeUpsertParams struct {
	Where  PropertyTypeWhereUniqueInput `json:"where"`
	Create PropertyTypeCreateInput      `json:"create"`
	Update PropertyTypeUpdateInput      `json:"update"`
}

func (client *Client) UpsertPropertyType(params PropertyTypeUpsertParams) *PropertyTypeExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"PropertyTypeWhereUniqueInput!", "PropertyTypeCreateInput!", "PropertyTypeUpdateInput!", "PropertyType"},
		"upsertPropertyType",
		[]string{"id", "type"})

	return &PropertyTypeExec{ret}
}

func (client *Client) DeletePropertyType(params PropertyTypeWhereUniqueInput) *PropertyTypeExec {
	ret := client.Client.Delete(
		params,
		[2]string{"PropertyTypeWhereUniqueInput!", "PropertyType"},
		"deletePropertyType",
		[]string{"id", "type"})

	return &PropertyTypeExec{ret}
}

func (client *Client) DeleteManyPropertyTypes(params *PropertyTypeWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "PropertyTypeWhereInput", "deleteManyPropertyTypes")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateTenant(params TenantCreateInput) *TenantExec {
	ret := client.Client.Create(
		params,
		[2]string{"TenantCreateInput!", "Tenant"},
		"createTenant",
		[]string{"id", "title", "firstName", "middleName", "lastName", "displayName", "personalEmail", "workEmail", "homenumber", "mobilenumber", "rentInterval", "day", "startDate", "endDate", "notes"})

	return &TenantExec{ret}
}

type TenantUpdateParams struct {
	Data  TenantUpdateInput      `json:"data"`
	Where TenantWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateTenant(params TenantUpdateParams) *TenantExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"TenantUpdateInput!", "TenantWhereUniqueInput!", "Tenant"},
		"updateTenant",
		[]string{"id", "title", "firstName", "middleName", "lastName", "displayName", "personalEmail", "workEmail", "homenumber", "mobilenumber", "rentInterval", "day", "startDate", "endDate", "notes"})

	return &TenantExec{ret}
}

type TenantUpdateManyParams struct {
	Data  TenantUpdateManyMutationInput `json:"data"`
	Where *TenantWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyTenants(params TenantUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"TenantUpdateManyMutationInput!", "TenantWhereInput"},
		"updateManyTenants")
	return &BatchPayloadExec{exec}
}

type TenantUpsertParams struct {
	Where  TenantWhereUniqueInput `json:"where"`
	Create TenantCreateInput      `json:"create"`
	Update TenantUpdateInput      `json:"update"`
}

func (client *Client) UpsertTenant(params TenantUpsertParams) *TenantExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"TenantWhereUniqueInput!", "TenantCreateInput!", "TenantUpdateInput!", "Tenant"},
		"upsertTenant",
		[]string{"id", "title", "firstName", "middleName", "lastName", "displayName", "personalEmail", "workEmail", "homenumber", "mobilenumber", "rentInterval", "day", "startDate", "endDate", "notes"})

	return &TenantExec{ret}
}

func (client *Client) DeleteTenant(params TenantWhereUniqueInput) *TenantExec {
	ret := client.Client.Delete(
		params,
		[2]string{"TenantWhereUniqueInput!", "Tenant"},
		"deleteTenant",
		[]string{"id", "title", "firstName", "middleName", "lastName", "displayName", "personalEmail", "workEmail", "homenumber", "mobilenumber", "rentInterval", "day", "startDate", "endDate", "notes"})

	return &TenantExec{ret}
}

func (client *Client) DeleteManyTenants(params *TenantWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "TenantWhereInput", "deleteManyTenants")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateTypeOfLet(params TypeOfLetCreateInput) *TypeOfLetExec {
	ret := client.Client.Create(
		params,
		[2]string{"TypeOfLetCreateInput!", "TypeOfLet"},
		"createTypeOfLet",
		[]string{"id", "name"})

	return &TypeOfLetExec{ret}
}

type TypeOfLetUpdateParams struct {
	Data  TypeOfLetUpdateInput      `json:"data"`
	Where TypeOfLetWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateTypeOfLet(params TypeOfLetUpdateParams) *TypeOfLetExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"TypeOfLetUpdateInput!", "TypeOfLetWhereUniqueInput!", "TypeOfLet"},
		"updateTypeOfLet",
		[]string{"id", "name"})

	return &TypeOfLetExec{ret}
}

type TypeOfLetUpdateManyParams struct {
	Data  TypeOfLetUpdateManyMutationInput `json:"data"`
	Where *TypeOfLetWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyTypeOfLets(params TypeOfLetUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"TypeOfLetUpdateManyMutationInput!", "TypeOfLetWhereInput"},
		"updateManyTypeOfLets")
	return &BatchPayloadExec{exec}
}

type TypeOfLetUpsertParams struct {
	Where  TypeOfLetWhereUniqueInput `json:"where"`
	Create TypeOfLetCreateInput      `json:"create"`
	Update TypeOfLetUpdateInput      `json:"update"`
}

func (client *Client) UpsertTypeOfLet(params TypeOfLetUpsertParams) *TypeOfLetExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"TypeOfLetWhereUniqueInput!", "TypeOfLetCreateInput!", "TypeOfLetUpdateInput!", "TypeOfLet"},
		"upsertTypeOfLet",
		[]string{"id", "name"})

	return &TypeOfLetExec{ret}
}

func (client *Client) DeleteTypeOfLet(params TypeOfLetWhereUniqueInput) *TypeOfLetExec {
	ret := client.Client.Delete(
		params,
		[2]string{"TypeOfLetWhereUniqueInput!", "TypeOfLet"},
		"deleteTypeOfLet",
		[]string{"id", "name"})

	return &TypeOfLetExec{ret}
}

func (client *Client) DeleteManyTypeOfLets(params *TypeOfLetWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "TypeOfLetWhereInput", "deleteManyTypeOfLets")
	return &BatchPayloadExec{exec}
}

type LandlordOrderByInput string

const (
	LandlordOrderByInputIDAsc          LandlordOrderByInput = "id_ASC"
	LandlordOrderByInputIDDesc         LandlordOrderByInput = "id_DESC"
	LandlordOrderByInputFullNameAsc    LandlordOrderByInput = "fullName_ASC"
	LandlordOrderByInputFullNameDesc   LandlordOrderByInput = "fullName_DESC"
	LandlordOrderByInputEmailAsc       LandlordOrderByInput = "email_ASC"
	LandlordOrderByInputEmailDesc      LandlordOrderByInput = "email_DESC"
	LandlordOrderByInputPasswordAsc    LandlordOrderByInput = "password_ASC"
	LandlordOrderByInputPasswordDesc   LandlordOrderByInput = "password_DESC"
	LandlordOrderByInputMobileAsc      LandlordOrderByInput = "mobile_ASC"
	LandlordOrderByInputMobileDesc     LandlordOrderByInput = "mobile_DESC"
	LandlordOrderByInputDobAsc         LandlordOrderByInput = "dob_ASC"
	LandlordOrderByInputDobDesc        LandlordOrderByInput = "dob_DESC"
	LandlordOrderByInputOccupationAsc  LandlordOrderByInput = "occupation_ASC"
	LandlordOrderByInputOccupationDesc LandlordOrderByInput = "occupation_DESC"
	LandlordOrderByInputAddress1Asc    LandlordOrderByInput = "address1_ASC"
	LandlordOrderByInputAddress1Desc   LandlordOrderByInput = "address1_DESC"
	LandlordOrderByInputAddress2Asc    LandlordOrderByInput = "address2_ASC"
	LandlordOrderByInputAddress2Desc   LandlordOrderByInput = "address2_DESC"
	LandlordOrderByInputPostcodeAsc    LandlordOrderByInput = "postcode_ASC"
	LandlordOrderByInputPostcodeDesc   LandlordOrderByInput = "postcode_DESC"
	LandlordOrderByInputCountryAsc     LandlordOrderByInput = "country_ASC"
	LandlordOrderByInputCountryDesc    LandlordOrderByInput = "country_DESC"
)

type PropertyOrderByInput string

const (
	PropertyOrderByInputIDAsc                     PropertyOrderByInput = "id_ASC"
	PropertyOrderByInputIDDesc                    PropertyOrderByInput = "id_DESC"
	PropertyOrderByInputAddress1Asc               PropertyOrderByInput = "address1_ASC"
	PropertyOrderByInputAddress1Desc              PropertyOrderByInput = "address1_DESC"
	PropertyOrderByInputAddress2Asc               PropertyOrderByInput = "address2_ASC"
	PropertyOrderByInputAddress2Desc              PropertyOrderByInput = "address2_DESC"
	PropertyOrderByInputPostcodeAsc               PropertyOrderByInput = "postcode_ASC"
	PropertyOrderByInputPostcodeDesc              PropertyOrderByInput = "postcode_DESC"
	PropertyOrderByInputCityAsc                   PropertyOrderByInput = "city_ASC"
	PropertyOrderByInputCityDesc                  PropertyOrderByInput = "city_DESC"
	PropertyOrderByInputCountryAsc                PropertyOrderByInput = "country_ASC"
	PropertyOrderByInputCountryDesc               PropertyOrderByInput = "country_DESC"
	PropertyOrderByInputPercentageofownershipAsc  PropertyOrderByInput = "percentageofownership_ASC"
	PropertyOrderByInputPercentageofownershipDesc PropertyOrderByInput = "percentageofownership_DESC"
	PropertyOrderByInputPurchasepriceAsc          PropertyOrderByInput = "purchaseprice_ASC"
	PropertyOrderByInputPurchasepriceDesc         PropertyOrderByInput = "purchaseprice_DESC"
	PropertyOrderByInputCurrentpriceAsc           PropertyOrderByInput = "currentprice_ASC"
	PropertyOrderByInputCurrentpriceDesc          PropertyOrderByInput = "currentprice_DESC"
	PropertyOrderByInputMortgageAmountAsc         PropertyOrderByInput = "mortgageAmount_ASC"
	PropertyOrderByInputMortgageAmountDesc        PropertyOrderByInput = "mortgageAmount_DESC"
	PropertyOrderByInputMortgageInterestRateAsc   PropertyOrderByInput = "mortgageInterestRate_ASC"
	PropertyOrderByInputMortgageInterestRateDesc  PropertyOrderByInput = "mortgageInterestRate_DESC"
	PropertyOrderByInputAnnualRentalIncomeAsc     PropertyOrderByInput = "annualRentalIncome_ASC"
	PropertyOrderByInputAnnualRentalIncomeDesc    PropertyOrderByInput = "annualRentalIncome_DESC"
	PropertyOrderByInputCurrencyAsc               PropertyOrderByInput = "currency_ASC"
	PropertyOrderByInputCurrencyDesc              PropertyOrderByInput = "currency_DESC"
)

type AgentOrderByInput string

const (
	AgentOrderByInputIDAsc               AgentOrderByInput = "id_ASC"
	AgentOrderByInputIDDesc              AgentOrderByInput = "id_DESC"
	AgentOrderByInputBusinessServiceAsc  AgentOrderByInput = "businessService_ASC"
	AgentOrderByInputBusinessServiceDesc AgentOrderByInput = "businessService_DESC"
	AgentOrderByInputTitleAsc            AgentOrderByInput = "title_ASC"
	AgentOrderByInputTitleDesc           AgentOrderByInput = "title_DESC"
	AgentOrderByInputFirstNameAsc        AgentOrderByInput = "firstName_ASC"
	AgentOrderByInputFirstNameDesc       AgentOrderByInput = "firstName_DESC"
	AgentOrderByInputLastNameAsc         AgentOrderByInput = "lastName_ASC"
	AgentOrderByInputLastNameDesc        AgentOrderByInput = "lastName_DESC"
	AgentOrderByInputDisplayNameAsc      AgentOrderByInput = "displayName_ASC"
	AgentOrderByInputDisplayNameDesc     AgentOrderByInput = "displayName_DESC"
	AgentOrderByInputEmailAsc            AgentOrderByInput = "email_ASC"
	AgentOrderByInputEmailDesc           AgentOrderByInput = "email_DESC"
	AgentOrderByInputPasswordAsc         AgentOrderByInput = "password_ASC"
	AgentOrderByInputPasswordDesc        AgentOrderByInput = "password_DESC"
	AgentOrderByInputMobileAsc           AgentOrderByInput = "mobile_ASC"
	AgentOrderByInputMobileDesc          AgentOrderByInput = "mobile_DESC"
	AgentOrderByInputFaxAsc              AgentOrderByInput = "fax_ASC"
	AgentOrderByInputFaxDesc             AgentOrderByInput = "fax_DESC"
	AgentOrderByInputAddress1Asc         AgentOrderByInput = "address1_ASC"
	AgentOrderByInputAddress1Desc        AgentOrderByInput = "address1_DESC"
	AgentOrderByInputAddress2Asc         AgentOrderByInput = "address2_ASC"
	AgentOrderByInputAddress2Desc        AgentOrderByInput = "address2_DESC"
	AgentOrderByInputPostcodeAsc         AgentOrderByInput = "postcode_ASC"
	AgentOrderByInputPostcodeDesc        AgentOrderByInput = "postcode_DESC"
	AgentOrderByInputCountryAsc          AgentOrderByInput = "country_ASC"
	AgentOrderByInputCountryDesc         AgentOrderByInput = "country_DESC"
	AgentOrderByInputWebsiteAsc          AgentOrderByInput = "website_ASC"
	AgentOrderByInputWebsiteDesc         AgentOrderByInput = "website_DESC"
)

type PropertyStatusOrderByInput string

const (
	PropertyStatusOrderByInputIDAsc      PropertyStatusOrderByInput = "id_ASC"
	PropertyStatusOrderByInputIDDesc     PropertyStatusOrderByInput = "id_DESC"
	PropertyStatusOrderByInputStatusAsc  PropertyStatusOrderByInput = "status_ASC"
	PropertyStatusOrderByInputStatusDesc PropertyStatusOrderByInput = "status_DESC"
)

type PropertyTypeOrderByInput string

const (
	PropertyTypeOrderByInputIDAsc    PropertyTypeOrderByInput = "id_ASC"
	PropertyTypeOrderByInputIDDesc   PropertyTypeOrderByInput = "id_DESC"
	PropertyTypeOrderByInputTypeAsc  PropertyTypeOrderByInput = "type_ASC"
	PropertyTypeOrderByInputTypeDesc PropertyTypeOrderByInput = "type_DESC"
)

type TenantOrderByInput string

const (
	TenantOrderByInputIDAsc             TenantOrderByInput = "id_ASC"
	TenantOrderByInputIDDesc            TenantOrderByInput = "id_DESC"
	TenantOrderByInputTitleAsc          TenantOrderByInput = "title_ASC"
	TenantOrderByInputTitleDesc         TenantOrderByInput = "title_DESC"
	TenantOrderByInputFirstNameAsc      TenantOrderByInput = "firstName_ASC"
	TenantOrderByInputFirstNameDesc     TenantOrderByInput = "firstName_DESC"
	TenantOrderByInputMiddleNameAsc     TenantOrderByInput = "middleName_ASC"
	TenantOrderByInputMiddleNameDesc    TenantOrderByInput = "middleName_DESC"
	TenantOrderByInputLastNameAsc       TenantOrderByInput = "lastName_ASC"
	TenantOrderByInputLastNameDesc      TenantOrderByInput = "lastName_DESC"
	TenantOrderByInputDisplayNameAsc    TenantOrderByInput = "displayName_ASC"
	TenantOrderByInputDisplayNameDesc   TenantOrderByInput = "displayName_DESC"
	TenantOrderByInputPersonalEmailAsc  TenantOrderByInput = "personalEmail_ASC"
	TenantOrderByInputPersonalEmailDesc TenantOrderByInput = "personalEmail_DESC"
	TenantOrderByInputWorkEmailAsc      TenantOrderByInput = "workEmail_ASC"
	TenantOrderByInputWorkEmailDesc     TenantOrderByInput = "workEmail_DESC"
	TenantOrderByInputHomenumberAsc     TenantOrderByInput = "homenumber_ASC"
	TenantOrderByInputHomenumberDesc    TenantOrderByInput = "homenumber_DESC"
	TenantOrderByInputMobilenumberAsc   TenantOrderByInput = "mobilenumber_ASC"
	TenantOrderByInputMobilenumberDesc  TenantOrderByInput = "mobilenumber_DESC"
	TenantOrderByInputRentIntervalAsc   TenantOrderByInput = "rentInterval_ASC"
	TenantOrderByInputRentIntervalDesc  TenantOrderByInput = "rentInterval_DESC"
	TenantOrderByInputDayAsc            TenantOrderByInput = "day_ASC"
	TenantOrderByInputDayDesc           TenantOrderByInput = "day_DESC"
	TenantOrderByInputStartDateAsc      TenantOrderByInput = "startDate_ASC"
	TenantOrderByInputStartDateDesc     TenantOrderByInput = "startDate_DESC"
	TenantOrderByInputEndDateAsc        TenantOrderByInput = "endDate_ASC"
	TenantOrderByInputEndDateDesc       TenantOrderByInput = "endDate_DESC"
	TenantOrderByInputNotesAsc          TenantOrderByInput = "notes_ASC"
	TenantOrderByInputNotesDesc         TenantOrderByInput = "notes_DESC"
)

type TypeOfLetOrderByInput string

const (
	TypeOfLetOrderByInputIDAsc    TypeOfLetOrderByInput = "id_ASC"
	TypeOfLetOrderByInputIDDesc   TypeOfLetOrderByInput = "id_DESC"
	TypeOfLetOrderByInputNameAsc  TypeOfLetOrderByInput = "name_ASC"
	TypeOfLetOrderByInputNameDesc TypeOfLetOrderByInput = "name_DESC"
)

type MutationType string

const (
	MutationTypeCreated MutationType = "CREATED"
	MutationTypeUpdated MutationType = "UPDATED"
	MutationTypeDeleted MutationType = "DELETED"
)

type PropertyUpdateWithoutLandlordsDataInput struct {
	Address1              *string                               `json:"address1,omitempty"`
	Address2              *string                               `json:"address2,omitempty"`
	Postcode              *string                               `json:"postcode,omitempty"`
	City                  *string                               `json:"city,omitempty"`
	Country               *string                               `json:"country,omitempty"`
	Percentageofownership *int32                                `json:"percentageofownership,omitempty"`
	Status                *PropertyStatusUpdateOneRequiredInput `json:"status,omitempty"`
	Type                  *PropertyTypeUpdateOneRequiredInput   `json:"type,omitempty"`
	Purchaseprice         *int32                                `json:"purchaseprice,omitempty"`
	Currentprice          *int32                                `json:"currentprice,omitempty"`
	MortgageAmount        *int32                                `json:"mortgageAmount,omitempty"`
	MortgageInterestRate  *int32                                `json:"mortgageInterestRate,omitempty"`
	AnnualRentalIncome    *int32                                `json:"annualRentalIncome,omitempty"`
	Currency              *string                               `json:"currency,omitempty"`
	Tenants               *TenantUpdateOneWithoutPropertyInput  `json:"tenants,omitempty"`
}

type AgentWhereUniqueInput struct {
	ID    *string `json:"id,omitempty"`
	Email *string `json:"email,omitempty"`
}

type PropertyTypeUpdateDataInput struct {
	Type *string `json:"type,omitempty"`
}

type PropertyTypeWhereInput struct {
	ID                *string                  `json:"id,omitempty"`
	IDNot             *string                  `json:"id_not,omitempty"`
	IDIn              []string                 `json:"id_in,omitempty"`
	IDNotIn           []string                 `json:"id_not_in,omitempty"`
	IDLt              *string                  `json:"id_lt,omitempty"`
	IDLte             *string                  `json:"id_lte,omitempty"`
	IDGt              *string                  `json:"id_gt,omitempty"`
	IDGte             *string                  `json:"id_gte,omitempty"`
	IDContains        *string                  `json:"id_contains,omitempty"`
	IDNotContains     *string                  `json:"id_not_contains,omitempty"`
	IDStartsWith      *string                  `json:"id_starts_with,omitempty"`
	IDNotStartsWith   *string                  `json:"id_not_starts_with,omitempty"`
	IDEndsWith        *string                  `json:"id_ends_with,omitempty"`
	IDNotEndsWith     *string                  `json:"id_not_ends_with,omitempty"`
	Type              *string                  `json:"type,omitempty"`
	TypeNot           *string                  `json:"type_not,omitempty"`
	TypeIn            []string                 `json:"type_in,omitempty"`
	TypeNotIn         []string                 `json:"type_not_in,omitempty"`
	TypeLt            *string                  `json:"type_lt,omitempty"`
	TypeLte           *string                  `json:"type_lte,omitempty"`
	TypeGt            *string                  `json:"type_gt,omitempty"`
	TypeGte           *string                  `json:"type_gte,omitempty"`
	TypeContains      *string                  `json:"type_contains,omitempty"`
	TypeNotContains   *string                  `json:"type_not_contains,omitempty"`
	TypeStartsWith    *string                  `json:"type_starts_with,omitempty"`
	TypeNotStartsWith *string                  `json:"type_not_starts_with,omitempty"`
	TypeEndsWith      *string                  `json:"type_ends_with,omitempty"`
	TypeNotEndsWith   *string                  `json:"type_not_ends_with,omitempty"`
	And               []PropertyTypeWhereInput `json:"AND,omitempty"`
	Or                []PropertyTypeWhereInput `json:"OR,omitempty"`
	Not               []PropertyTypeWhereInput `json:"NOT,omitempty"`
}

type PropertyTypeUpsertNestedInput struct {
	Update PropertyTypeUpdateDataInput `json:"update"`
	Create PropertyTypeCreateInput     `json:"create"`
}

type TypeOfLetWhereInput struct {
	ID                *string               `json:"id,omitempty"`
	IDNot             *string               `json:"id_not,omitempty"`
	IDIn              []string              `json:"id_in,omitempty"`
	IDNotIn           []string              `json:"id_not_in,omitempty"`
	IDLt              *string               `json:"id_lt,omitempty"`
	IDLte             *string               `json:"id_lte,omitempty"`
	IDGt              *string               `json:"id_gt,omitempty"`
	IDGte             *string               `json:"id_gte,omitempty"`
	IDContains        *string               `json:"id_contains,omitempty"`
	IDNotContains     *string               `json:"id_not_contains,omitempty"`
	IDStartsWith      *string               `json:"id_starts_with,omitempty"`
	IDNotStartsWith   *string               `json:"id_not_starts_with,omitempty"`
	IDEndsWith        *string               `json:"id_ends_with,omitempty"`
	IDNotEndsWith     *string               `json:"id_not_ends_with,omitempty"`
	Name              *string               `json:"name,omitempty"`
	NameNot           *string               `json:"name_not,omitempty"`
	NameIn            []string              `json:"name_in,omitempty"`
	NameNotIn         []string              `json:"name_not_in,omitempty"`
	NameLt            *string               `json:"name_lt,omitempty"`
	NameLte           *string               `json:"name_lte,omitempty"`
	NameGt            *string               `json:"name_gt,omitempty"`
	NameGte           *string               `json:"name_gte,omitempty"`
	NameContains      *string               `json:"name_contains,omitempty"`
	NameNotContains   *string               `json:"name_not_contains,omitempty"`
	NameStartsWith    *string               `json:"name_starts_with,omitempty"`
	NameNotStartsWith *string               `json:"name_not_starts_with,omitempty"`
	NameEndsWith      *string               `json:"name_ends_with,omitempty"`
	NameNotEndsWith   *string               `json:"name_not_ends_with,omitempty"`
	And               []TypeOfLetWhereInput `json:"AND,omitempty"`
	Or                []TypeOfLetWhereInput `json:"OR,omitempty"`
	Not               []TypeOfLetWhereInput `json:"NOT,omitempty"`
}

type LandlordCreateWithoutAgentInput struct {
	FullName   string                                   `json:"fullName"`
	Email      string                                   `json:"email"`
	Password   *string                                  `json:"password,omitempty"`
	Mobile     *int32                                   `json:"mobile,omitempty"`
	Dob        *string                                  `json:"dob,omitempty"`
	Occupation *string                                  `json:"occupation,omitempty"`
	Address1   *string                                  `json:"address1,omitempty"`
	Address2   *string                                  `json:"address2,omitempty"`
	Postcode   string                                   `json:"postcode"`
	Country    string                                   `json:"country"`
	Properties *PropertyCreateManyWithoutLandlordsInput `json:"properties,omitempty"`
}

type AgentCreateWithoutClientsInput struct {
	BusinessService *string `json:"businessService,omitempty"`
	Title           *string `json:"title,omitempty"`
	FirstName       string  `json:"firstName"`
	LastName        *string `json:"lastName,omitempty"`
	DisplayName     *string `json:"displayName,omitempty"`
	Email           string  `json:"email"`
	Password        *string `json:"password,omitempty"`
	Mobile          *int32  `json:"mobile,omitempty"`
	Fax             *int32  `json:"fax,omitempty"`
	Address1        *string `json:"address1,omitempty"`
	Address2        *string `json:"address2,omitempty"`
	Postcode        string  `json:"postcode"`
	Country         string  `json:"country"`
	Website         *string `json:"website,omitempty"`
}

type PropertyCreateManyWithoutLandlordsInput struct {
	Create  []PropertyCreateWithoutLandlordsInput `json:"create,omitempty"`
	Connect []PropertyWhereUniqueInput            `json:"connect,omitempty"`
}

type TenantUpdateOneWithoutPropertyInput struct {
	Create     *TenantCreateWithoutPropertyInput     `json:"create,omitempty"`
	Update     *TenantUpdateWithoutPropertyDataInput `json:"update,omitempty"`
	Upsert     *TenantUpsertWithoutPropertyInput     `json:"upsert,omitempty"`
	Delete     *bool                                 `json:"delete,omitempty"`
	Disconnect *bool                                 `json:"disconnect,omitempty"`
	Connect    *TenantWhereUniqueInput               `json:"connect,omitempty"`
}

type PropertyCreateWithoutLandlordsInput struct {
	Address1              string                               `json:"address1"`
	Address2              *string                              `json:"address2,omitempty"`
	Postcode              string                               `json:"postcode"`
	City                  string                               `json:"city"`
	Country               string                               `json:"country"`
	Percentageofownership *int32                               `json:"percentageofownership,omitempty"`
	Status                PropertyStatusCreateOneInput         `json:"status"`
	Type                  PropertyTypeCreateOneInput           `json:"type"`
	Purchaseprice         *int32                               `json:"purchaseprice,omitempty"`
	Currentprice          *int32                               `json:"currentprice,omitempty"`
	MortgageAmount        *int32                               `json:"mortgageAmount,omitempty"`
	MortgageInterestRate  *int32                               `json:"mortgageInterestRate,omitempty"`
	AnnualRentalIncome    *int32                               `json:"annualRentalIncome,omitempty"`
	Currency              *string                              `json:"currency,omitempty"`
	Tenants               *TenantCreateOneWithoutPropertyInput `json:"tenants,omitempty"`
}

type TenantSubscriptionWhereInput struct {
	MutationIn                 []MutationType                 `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                        `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                       `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                       `json:"updatedFields_contains_some,omitempty"`
	Node                       *TenantWhereInput              `json:"node,omitempty"`
	And                        []TenantSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []TenantSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []TenantSubscriptionWhereInput `json:"NOT,omitempty"`
}

type PropertyStatusCreateOneInput struct {
	Create  *PropertyStatusCreateInput      `json:"create,omitempty"`
	Connect *PropertyStatusWhereUniqueInput `json:"connect,omitempty"`
}

type PropertyStatusSubscriptionWhereInput struct {
	MutationIn                 []MutationType                         `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                               `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                               `json:"updatedFields_contains_some,omitempty"`
	Node                       *PropertyStatusWhereInput              `json:"node,omitempty"`
	And                        []PropertyStatusSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []PropertyStatusSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []PropertyStatusSubscriptionWhereInput `json:"NOT,omitempty"`
}

type PropertyStatusCreateInput struct {
	Status string `json:"status"`
}

type AgentWhereInput struct {
	ID                           *string             `json:"id,omitempty"`
	IDNot                        *string             `json:"id_not,omitempty"`
	IDIn                         []string            `json:"id_in,omitempty"`
	IDNotIn                      []string            `json:"id_not_in,omitempty"`
	IDLt                         *string             `json:"id_lt,omitempty"`
	IDLte                        *string             `json:"id_lte,omitempty"`
	IDGt                         *string             `json:"id_gt,omitempty"`
	IDGte                        *string             `json:"id_gte,omitempty"`
	IDContains                   *string             `json:"id_contains,omitempty"`
	IDNotContains                *string             `json:"id_not_contains,omitempty"`
	IDStartsWith                 *string             `json:"id_starts_with,omitempty"`
	IDNotStartsWith              *string             `json:"id_not_starts_with,omitempty"`
	IDEndsWith                   *string             `json:"id_ends_with,omitempty"`
	IDNotEndsWith                *string             `json:"id_not_ends_with,omitempty"`
	BusinessService              *string             `json:"businessService,omitempty"`
	BusinessServiceNot           *string             `json:"businessService_not,omitempty"`
	BusinessServiceIn            []string            `json:"businessService_in,omitempty"`
	BusinessServiceNotIn         []string            `json:"businessService_not_in,omitempty"`
	BusinessServiceLt            *string             `json:"businessService_lt,omitempty"`
	BusinessServiceLte           *string             `json:"businessService_lte,omitempty"`
	BusinessServiceGt            *string             `json:"businessService_gt,omitempty"`
	BusinessServiceGte           *string             `json:"businessService_gte,omitempty"`
	BusinessServiceContains      *string             `json:"businessService_contains,omitempty"`
	BusinessServiceNotContains   *string             `json:"businessService_not_contains,omitempty"`
	BusinessServiceStartsWith    *string             `json:"businessService_starts_with,omitempty"`
	BusinessServiceNotStartsWith *string             `json:"businessService_not_starts_with,omitempty"`
	BusinessServiceEndsWith      *string             `json:"businessService_ends_with,omitempty"`
	BusinessServiceNotEndsWith   *string             `json:"businessService_not_ends_with,omitempty"`
	Title                        *string             `json:"title,omitempty"`
	TitleNot                     *string             `json:"title_not,omitempty"`
	TitleIn                      []string            `json:"title_in,omitempty"`
	TitleNotIn                   []string            `json:"title_not_in,omitempty"`
	TitleLt                      *string             `json:"title_lt,omitempty"`
	TitleLte                     *string             `json:"title_lte,omitempty"`
	TitleGt                      *string             `json:"title_gt,omitempty"`
	TitleGte                     *string             `json:"title_gte,omitempty"`
	TitleContains                *string             `json:"title_contains,omitempty"`
	TitleNotContains             *string             `json:"title_not_contains,omitempty"`
	TitleStartsWith              *string             `json:"title_starts_with,omitempty"`
	TitleNotStartsWith           *string             `json:"title_not_starts_with,omitempty"`
	TitleEndsWith                *string             `json:"title_ends_with,omitempty"`
	TitleNotEndsWith             *string             `json:"title_not_ends_with,omitempty"`
	FirstName                    *string             `json:"firstName,omitempty"`
	FirstNameNot                 *string             `json:"firstName_not,omitempty"`
	FirstNameIn                  []string            `json:"firstName_in,omitempty"`
	FirstNameNotIn               []string            `json:"firstName_not_in,omitempty"`
	FirstNameLt                  *string             `json:"firstName_lt,omitempty"`
	FirstNameLte                 *string             `json:"firstName_lte,omitempty"`
	FirstNameGt                  *string             `json:"firstName_gt,omitempty"`
	FirstNameGte                 *string             `json:"firstName_gte,omitempty"`
	FirstNameContains            *string             `json:"firstName_contains,omitempty"`
	FirstNameNotContains         *string             `json:"firstName_not_contains,omitempty"`
	FirstNameStartsWith          *string             `json:"firstName_starts_with,omitempty"`
	FirstNameNotStartsWith       *string             `json:"firstName_not_starts_with,omitempty"`
	FirstNameEndsWith            *string             `json:"firstName_ends_with,omitempty"`
	FirstNameNotEndsWith         *string             `json:"firstName_not_ends_with,omitempty"`
	LastName                     *string             `json:"lastName,omitempty"`
	LastNameNot                  *string             `json:"lastName_not,omitempty"`
	LastNameIn                   []string            `json:"lastName_in,omitempty"`
	LastNameNotIn                []string            `json:"lastName_not_in,omitempty"`
	LastNameLt                   *string             `json:"lastName_lt,omitempty"`
	LastNameLte                  *string             `json:"lastName_lte,omitempty"`
	LastNameGt                   *string             `json:"lastName_gt,omitempty"`
	LastNameGte                  *string             `json:"lastName_gte,omitempty"`
	LastNameContains             *string             `json:"lastName_contains,omitempty"`
	LastNameNotContains          *string             `json:"lastName_not_contains,omitempty"`
	LastNameStartsWith           *string             `json:"lastName_starts_with,omitempty"`
	LastNameNotStartsWith        *string             `json:"lastName_not_starts_with,omitempty"`
	LastNameEndsWith             *string             `json:"lastName_ends_with,omitempty"`
	LastNameNotEndsWith          *string             `json:"lastName_not_ends_with,omitempty"`
	DisplayName                  *string             `json:"displayName,omitempty"`
	DisplayNameNot               *string             `json:"displayName_not,omitempty"`
	DisplayNameIn                []string            `json:"displayName_in,omitempty"`
	DisplayNameNotIn             []string            `json:"displayName_not_in,omitempty"`
	DisplayNameLt                *string             `json:"displayName_lt,omitempty"`
	DisplayNameLte               *string             `json:"displayName_lte,omitempty"`
	DisplayNameGt                *string             `json:"displayName_gt,omitempty"`
	DisplayNameGte               *string             `json:"displayName_gte,omitempty"`
	DisplayNameContains          *string             `json:"displayName_contains,omitempty"`
	DisplayNameNotContains       *string             `json:"displayName_not_contains,omitempty"`
	DisplayNameStartsWith        *string             `json:"displayName_starts_with,omitempty"`
	DisplayNameNotStartsWith     *string             `json:"displayName_not_starts_with,omitempty"`
	DisplayNameEndsWith          *string             `json:"displayName_ends_with,omitempty"`
	DisplayNameNotEndsWith       *string             `json:"displayName_not_ends_with,omitempty"`
	Email                        *string             `json:"email,omitempty"`
	EmailNot                     *string             `json:"email_not,omitempty"`
	EmailIn                      []string            `json:"email_in,omitempty"`
	EmailNotIn                   []string            `json:"email_not_in,omitempty"`
	EmailLt                      *string             `json:"email_lt,omitempty"`
	EmailLte                     *string             `json:"email_lte,omitempty"`
	EmailGt                      *string             `json:"email_gt,omitempty"`
	EmailGte                     *string             `json:"email_gte,omitempty"`
	EmailContains                *string             `json:"email_contains,omitempty"`
	EmailNotContains             *string             `json:"email_not_contains,omitempty"`
	EmailStartsWith              *string             `json:"email_starts_with,omitempty"`
	EmailNotStartsWith           *string             `json:"email_not_starts_with,omitempty"`
	EmailEndsWith                *string             `json:"email_ends_with,omitempty"`
	EmailNotEndsWith             *string             `json:"email_not_ends_with,omitempty"`
	Password                     *string             `json:"password,omitempty"`
	PasswordNot                  *string             `json:"password_not,omitempty"`
	PasswordIn                   []string            `json:"password_in,omitempty"`
	PasswordNotIn                []string            `json:"password_not_in,omitempty"`
	PasswordLt                   *string             `json:"password_lt,omitempty"`
	PasswordLte                  *string             `json:"password_lte,omitempty"`
	PasswordGt                   *string             `json:"password_gt,omitempty"`
	PasswordGte                  *string             `json:"password_gte,omitempty"`
	PasswordContains             *string             `json:"password_contains,omitempty"`
	PasswordNotContains          *string             `json:"password_not_contains,omitempty"`
	PasswordStartsWith           *string             `json:"password_starts_with,omitempty"`
	PasswordNotStartsWith        *string             `json:"password_not_starts_with,omitempty"`
	PasswordEndsWith             *string             `json:"password_ends_with,omitempty"`
	PasswordNotEndsWith          *string             `json:"password_not_ends_with,omitempty"`
	Mobile                       *int32              `json:"mobile,omitempty"`
	MobileNot                    *int32              `json:"mobile_not,omitempty"`
	MobileIn                     []int32             `json:"mobile_in,omitempty"`
	MobileNotIn                  []int32             `json:"mobile_not_in,omitempty"`
	MobileLt                     *int32              `json:"mobile_lt,omitempty"`
	MobileLte                    *int32              `json:"mobile_lte,omitempty"`
	MobileGt                     *int32              `json:"mobile_gt,omitempty"`
	MobileGte                    *int32              `json:"mobile_gte,omitempty"`
	Fax                          *int32              `json:"fax,omitempty"`
	FaxNot                       *int32              `json:"fax_not,omitempty"`
	FaxIn                        []int32             `json:"fax_in,omitempty"`
	FaxNotIn                     []int32             `json:"fax_not_in,omitempty"`
	FaxLt                        *int32              `json:"fax_lt,omitempty"`
	FaxLte                       *int32              `json:"fax_lte,omitempty"`
	FaxGt                        *int32              `json:"fax_gt,omitempty"`
	FaxGte                       *int32              `json:"fax_gte,omitempty"`
	Address1                     *string             `json:"address1,omitempty"`
	Address1Not                  *string             `json:"address1_not,omitempty"`
	Address1In                   []string            `json:"address1_in,omitempty"`
	Address1NotIn                []string            `json:"address1_not_in,omitempty"`
	Address1Lt                   *string             `json:"address1_lt,omitempty"`
	Address1Lte                  *string             `json:"address1_lte,omitempty"`
	Address1Gt                   *string             `json:"address1_gt,omitempty"`
	Address1Gte                  *string             `json:"address1_gte,omitempty"`
	Address1Contains             *string             `json:"address1_contains,omitempty"`
	Address1NotContains          *string             `json:"address1_not_contains,omitempty"`
	Address1StartsWith           *string             `json:"address1_starts_with,omitempty"`
	Address1NotStartsWith        *string             `json:"address1_not_starts_with,omitempty"`
	Address1EndsWith             *string             `json:"address1_ends_with,omitempty"`
	Address1NotEndsWith          *string             `json:"address1_not_ends_with,omitempty"`
	Address2                     *string             `json:"address2,omitempty"`
	Address2Not                  *string             `json:"address2_not,omitempty"`
	Address2In                   []string            `json:"address2_in,omitempty"`
	Address2NotIn                []string            `json:"address2_not_in,omitempty"`
	Address2Lt                   *string             `json:"address2_lt,omitempty"`
	Address2Lte                  *string             `json:"address2_lte,omitempty"`
	Address2Gt                   *string             `json:"address2_gt,omitempty"`
	Address2Gte                  *string             `json:"address2_gte,omitempty"`
	Address2Contains             *string             `json:"address2_contains,omitempty"`
	Address2NotContains          *string             `json:"address2_not_contains,omitempty"`
	Address2StartsWith           *string             `json:"address2_starts_with,omitempty"`
	Address2NotStartsWith        *string             `json:"address2_not_starts_with,omitempty"`
	Address2EndsWith             *string             `json:"address2_ends_with,omitempty"`
	Address2NotEndsWith          *string             `json:"address2_not_ends_with,omitempty"`
	Postcode                     *string             `json:"postcode,omitempty"`
	PostcodeNot                  *string             `json:"postcode_not,omitempty"`
	PostcodeIn                   []string            `json:"postcode_in,omitempty"`
	PostcodeNotIn                []string            `json:"postcode_not_in,omitempty"`
	PostcodeLt                   *string             `json:"postcode_lt,omitempty"`
	PostcodeLte                  *string             `json:"postcode_lte,omitempty"`
	PostcodeGt                   *string             `json:"postcode_gt,omitempty"`
	PostcodeGte                  *string             `json:"postcode_gte,omitempty"`
	PostcodeContains             *string             `json:"postcode_contains,omitempty"`
	PostcodeNotContains          *string             `json:"postcode_not_contains,omitempty"`
	PostcodeStartsWith           *string             `json:"postcode_starts_with,omitempty"`
	PostcodeNotStartsWith        *string             `json:"postcode_not_starts_with,omitempty"`
	PostcodeEndsWith             *string             `json:"postcode_ends_with,omitempty"`
	PostcodeNotEndsWith          *string             `json:"postcode_not_ends_with,omitempty"`
	Country                      *string             `json:"country,omitempty"`
	CountryNot                   *string             `json:"country_not,omitempty"`
	CountryIn                    []string            `json:"country_in,omitempty"`
	CountryNotIn                 []string            `json:"country_not_in,omitempty"`
	CountryLt                    *string             `json:"country_lt,omitempty"`
	CountryLte                   *string             `json:"country_lte,omitempty"`
	CountryGt                    *string             `json:"country_gt,omitempty"`
	CountryGte                   *string             `json:"country_gte,omitempty"`
	CountryContains              *string             `json:"country_contains,omitempty"`
	CountryNotContains           *string             `json:"country_not_contains,omitempty"`
	CountryStartsWith            *string             `json:"country_starts_with,omitempty"`
	CountryNotStartsWith         *string             `json:"country_not_starts_with,omitempty"`
	CountryEndsWith              *string             `json:"country_ends_with,omitempty"`
	CountryNotEndsWith           *string             `json:"country_not_ends_with,omitempty"`
	Website                      *string             `json:"website,omitempty"`
	WebsiteNot                   *string             `json:"website_not,omitempty"`
	WebsiteIn                    []string            `json:"website_in,omitempty"`
	WebsiteNotIn                 []string            `json:"website_not_in,omitempty"`
	WebsiteLt                    *string             `json:"website_lt,omitempty"`
	WebsiteLte                   *string             `json:"website_lte,omitempty"`
	WebsiteGt                    *string             `json:"website_gt,omitempty"`
	WebsiteGte                   *string             `json:"website_gte,omitempty"`
	WebsiteContains              *string             `json:"website_contains,omitempty"`
	WebsiteNotContains           *string             `json:"website_not_contains,omitempty"`
	WebsiteStartsWith            *string             `json:"website_starts_with,omitempty"`
	WebsiteNotStartsWith         *string             `json:"website_not_starts_with,omitempty"`
	WebsiteEndsWith              *string             `json:"website_ends_with,omitempty"`
	WebsiteNotEndsWith           *string             `json:"website_not_ends_with,omitempty"`
	ClientsEvery                 *LandlordWhereInput `json:"clients_every,omitempty"`
	ClientsSome                  *LandlordWhereInput `json:"clients_some,omitempty"`
	ClientsNone                  *LandlordWhereInput `json:"clients_none,omitempty"`
	And                          []AgentWhereInput   `json:"AND,omitempty"`
	Or                           []AgentWhereInput   `json:"OR,omitempty"`
	Not                          []AgentWhereInput   `json:"NOT,omitempty"`
}

type PropertyTypeCreateOneInput struct {
	Create  *PropertyTypeCreateInput      `json:"create,omitempty"`
	Connect *PropertyTypeWhereUniqueInput `json:"connect,omitempty"`
}

type AgentSubscriptionWhereInput struct {
	MutationIn                 []MutationType                `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                       `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                      `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                      `json:"updatedFields_contains_some,omitempty"`
	Node                       *AgentWhereInput              `json:"node,omitempty"`
	And                        []AgentSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []AgentSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []AgentSubscriptionWhereInput `json:"NOT,omitempty"`
}

type PropertyTypeCreateInput struct {
	Type string `json:"type"`
}

type TypeOfLetUpdateInput struct {
	Name *string `json:"name,omitempty"`
}

type TenantCreateOneWithoutPropertyInput struct {
	Create  *TenantCreateWithoutPropertyInput `json:"create,omitempty"`
	Connect *TenantWhereUniqueInput           `json:"connect,omitempty"`
}

type LandlordWhereUniqueInput struct {
	ID    *string `json:"id,omitempty"`
	Email *string `json:"email,omitempty"`
}

type TenantCreateWithoutPropertyInput struct {
	Title         *string                 `json:"title,omitempty"`
	FirstName     string                  `json:"firstName"`
	MiddleName    *string                 `json:"middleName,omitempty"`
	LastName      *string                 `json:"lastName,omitempty"`
	DisplayName   string                  `json:"displayName"`
	PersonalEmail string                  `json:"personalEmail"`
	WorkEmail     string                  `json:"workEmail"`
	Homenumber    *int32                  `json:"homenumber,omitempty"`
	Mobilenumber  *int32                  `json:"mobilenumber,omitempty"`
	TypeOfLet     TypeOfLetCreateOneInput `json:"typeOfLet"`
	RentInterval  string                  `json:"rentInterval"`
	Day           *string                 `json:"day,omitempty"`
	StartDate     *string                 `json:"startDate,omitempty"`
	EndDate       *string                 `json:"endDate,omitempty"`
	Notes         *string                 `json:"notes,omitempty"`
}

type PropertyUpdateWithoutTenantsDataInput struct {
	Address1              *string                                  `json:"address1,omitempty"`
	Address2              *string                                  `json:"address2,omitempty"`
	Postcode              *string                                  `json:"postcode,omitempty"`
	City                  *string                                  `json:"city,omitempty"`
	Country               *string                                  `json:"country,omitempty"`
	Percentageofownership *int32                                   `json:"percentageofownership,omitempty"`
	Status                *PropertyStatusUpdateOneRequiredInput    `json:"status,omitempty"`
	Type                  *PropertyTypeUpdateOneRequiredInput      `json:"type,omitempty"`
	Purchaseprice         *int32                                   `json:"purchaseprice,omitempty"`
	Currentprice          *int32                                   `json:"currentprice,omitempty"`
	MortgageAmount        *int32                                   `json:"mortgageAmount,omitempty"`
	MortgageInterestRate  *int32                                   `json:"mortgageInterestRate,omitempty"`
	AnnualRentalIncome    *int32                                   `json:"annualRentalIncome,omitempty"`
	Currency              *string                                  `json:"currency,omitempty"`
	Landlords             *LandlordUpdateOneWithoutPropertiesInput `json:"landlords,omitempty"`
}

type TypeOfLetCreateOneInput struct {
	Create  *TypeOfLetCreateInput      `json:"create,omitempty"`
	Connect *TypeOfLetWhereUniqueInput `json:"connect,omitempty"`
}

type PropertyWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type TypeOfLetCreateInput struct {
	Name *string `json:"name,omitempty"`
}

type PropertyCreateWithoutTenantsInput struct {
	Address1              string                                   `json:"address1"`
	Address2              *string                                  `json:"address2,omitempty"`
	Postcode              string                                   `json:"postcode"`
	City                  string                                   `json:"city"`
	Country               string                                   `json:"country"`
	Percentageofownership *int32                                   `json:"percentageofownership,omitempty"`
	Status                PropertyStatusCreateOneInput             `json:"status"`
	Type                  PropertyTypeCreateOneInput               `json:"type"`
	Purchaseprice         *int32                                   `json:"purchaseprice,omitempty"`
	Currentprice          *int32                                   `json:"currentprice,omitempty"`
	MortgageAmount        *int32                                   `json:"mortgageAmount,omitempty"`
	MortgageInterestRate  *int32                                   `json:"mortgageInterestRate,omitempty"`
	AnnualRentalIncome    *int32                                   `json:"annualRentalIncome,omitempty"`
	Currency              *string                                  `json:"currency,omitempty"`
	Landlords             *LandlordCreateOneWithoutPropertiesInput `json:"landlords,omitempty"`
}

type AgentUpdateInput struct {
	BusinessService *string                              `json:"businessService,omitempty"`
	Title           *string                              `json:"title,omitempty"`
	FirstName       *string                              `json:"firstName,omitempty"`
	LastName        *string                              `json:"lastName,omitempty"`
	DisplayName     *string                              `json:"displayName,omitempty"`
	Email           *string                              `json:"email,omitempty"`
	Password        *string                              `json:"password,omitempty"`
	Mobile          *int32                               `json:"mobile,omitempty"`
	Fax             *int32                               `json:"fax,omitempty"`
	Address1        *string                              `json:"address1,omitempty"`
	Address2        *string                              `json:"address2,omitempty"`
	Postcode        *string                              `json:"postcode,omitempty"`
	Country         *string                              `json:"country,omitempty"`
	Website         *string                              `json:"website,omitempty"`
	Clients         *LandlordUpdateManyWithoutAgentInput `json:"clients,omitempty"`
}

type PropertyStatusWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type LandlordUpdateManyWithoutAgentInput struct {
	Create     []LandlordCreateWithoutAgentInput                `json:"create,omitempty"`
	Delete     []LandlordWhereUniqueInput                       `json:"delete,omitempty"`
	Connect    []LandlordWhereUniqueInput                       `json:"connect,omitempty"`
	Set        []LandlordWhereUniqueInput                       `json:"set,omitempty"`
	Disconnect []LandlordWhereUniqueInput                       `json:"disconnect,omitempty"`
	Update     []LandlordUpdateWithWhereUniqueWithoutAgentInput `json:"update,omitempty"`
	Upsert     []LandlordUpsertWithWhereUniqueWithoutAgentInput `json:"upsert,omitempty"`
	DeleteMany []LandlordScalarWhereInput                       `json:"deleteMany,omitempty"`
	UpdateMany []LandlordUpdateManyWithWhereNestedInput         `json:"updateMany,omitempty"`
}

type PropertyTypeUpdateManyMutationInput struct {
	Type *string `json:"type,omitempty"`
}

type LandlordUpdateWithWhereUniqueWithoutAgentInput struct {
	Where LandlordWhereUniqueInput            `json:"where"`
	Data  LandlordUpdateWithoutAgentDataInput `json:"data"`
}

type PropertyStatusUpdateManyMutationInput struct {
	Status *string `json:"status,omitempty"`
}

type LandlordUpdateWithoutAgentDataInput struct {
	FullName   *string                                  `json:"fullName,omitempty"`
	Email      *string                                  `json:"email,omitempty"`
	Password   *string                                  `json:"password,omitempty"`
	Mobile     *int32                                   `json:"mobile,omitempty"`
	Dob        *string                                  `json:"dob,omitempty"`
	Occupation *string                                  `json:"occupation,omitempty"`
	Address1   *string                                  `json:"address1,omitempty"`
	Address2   *string                                  `json:"address2,omitempty"`
	Postcode   *string                                  `json:"postcode,omitempty"`
	Country    *string                                  `json:"country,omitempty"`
	Properties *PropertyUpdateManyWithoutLandlordsInput `json:"properties,omitempty"`
}

type LandlordWhereInput struct {
	ID                      *string              `json:"id,omitempty"`
	IDNot                   *string              `json:"id_not,omitempty"`
	IDIn                    []string             `json:"id_in,omitempty"`
	IDNotIn                 []string             `json:"id_not_in,omitempty"`
	IDLt                    *string              `json:"id_lt,omitempty"`
	IDLte                   *string              `json:"id_lte,omitempty"`
	IDGt                    *string              `json:"id_gt,omitempty"`
	IDGte                   *string              `json:"id_gte,omitempty"`
	IDContains              *string              `json:"id_contains,omitempty"`
	IDNotContains           *string              `json:"id_not_contains,omitempty"`
	IDStartsWith            *string              `json:"id_starts_with,omitempty"`
	IDNotStartsWith         *string              `json:"id_not_starts_with,omitempty"`
	IDEndsWith              *string              `json:"id_ends_with,omitempty"`
	IDNotEndsWith           *string              `json:"id_not_ends_with,omitempty"`
	FullName                *string              `json:"fullName,omitempty"`
	FullNameNot             *string              `json:"fullName_not,omitempty"`
	FullNameIn              []string             `json:"fullName_in,omitempty"`
	FullNameNotIn           []string             `json:"fullName_not_in,omitempty"`
	FullNameLt              *string              `json:"fullName_lt,omitempty"`
	FullNameLte             *string              `json:"fullName_lte,omitempty"`
	FullNameGt              *string              `json:"fullName_gt,omitempty"`
	FullNameGte             *string              `json:"fullName_gte,omitempty"`
	FullNameContains        *string              `json:"fullName_contains,omitempty"`
	FullNameNotContains     *string              `json:"fullName_not_contains,omitempty"`
	FullNameStartsWith      *string              `json:"fullName_starts_with,omitempty"`
	FullNameNotStartsWith   *string              `json:"fullName_not_starts_with,omitempty"`
	FullNameEndsWith        *string              `json:"fullName_ends_with,omitempty"`
	FullNameNotEndsWith     *string              `json:"fullName_not_ends_with,omitempty"`
	Email                   *string              `json:"email,omitempty"`
	EmailNot                *string              `json:"email_not,omitempty"`
	EmailIn                 []string             `json:"email_in,omitempty"`
	EmailNotIn              []string             `json:"email_not_in,omitempty"`
	EmailLt                 *string              `json:"email_lt,omitempty"`
	EmailLte                *string              `json:"email_lte,omitempty"`
	EmailGt                 *string              `json:"email_gt,omitempty"`
	EmailGte                *string              `json:"email_gte,omitempty"`
	EmailContains           *string              `json:"email_contains,omitempty"`
	EmailNotContains        *string              `json:"email_not_contains,omitempty"`
	EmailStartsWith         *string              `json:"email_starts_with,omitempty"`
	EmailNotStartsWith      *string              `json:"email_not_starts_with,omitempty"`
	EmailEndsWith           *string              `json:"email_ends_with,omitempty"`
	EmailNotEndsWith        *string              `json:"email_not_ends_with,omitempty"`
	Password                *string              `json:"password,omitempty"`
	PasswordNot             *string              `json:"password_not,omitempty"`
	PasswordIn              []string             `json:"password_in,omitempty"`
	PasswordNotIn           []string             `json:"password_not_in,omitempty"`
	PasswordLt              *string              `json:"password_lt,omitempty"`
	PasswordLte             *string              `json:"password_lte,omitempty"`
	PasswordGt              *string              `json:"password_gt,omitempty"`
	PasswordGte             *string              `json:"password_gte,omitempty"`
	PasswordContains        *string              `json:"password_contains,omitempty"`
	PasswordNotContains     *string              `json:"password_not_contains,omitempty"`
	PasswordStartsWith      *string              `json:"password_starts_with,omitempty"`
	PasswordNotStartsWith   *string              `json:"password_not_starts_with,omitempty"`
	PasswordEndsWith        *string              `json:"password_ends_with,omitempty"`
	PasswordNotEndsWith     *string              `json:"password_not_ends_with,omitempty"`
	Mobile                  *int32               `json:"mobile,omitempty"`
	MobileNot               *int32               `json:"mobile_not,omitempty"`
	MobileIn                []int32              `json:"mobile_in,omitempty"`
	MobileNotIn             []int32              `json:"mobile_not_in,omitempty"`
	MobileLt                *int32               `json:"mobile_lt,omitempty"`
	MobileLte               *int32               `json:"mobile_lte,omitempty"`
	MobileGt                *int32               `json:"mobile_gt,omitempty"`
	MobileGte               *int32               `json:"mobile_gte,omitempty"`
	Dob                     *string              `json:"dob,omitempty"`
	DobNot                  *string              `json:"dob_not,omitempty"`
	DobIn                   []string             `json:"dob_in,omitempty"`
	DobNotIn                []string             `json:"dob_not_in,omitempty"`
	DobLt                   *string              `json:"dob_lt,omitempty"`
	DobLte                  *string              `json:"dob_lte,omitempty"`
	DobGt                   *string              `json:"dob_gt,omitempty"`
	DobGte                  *string              `json:"dob_gte,omitempty"`
	Occupation              *string              `json:"occupation,omitempty"`
	OccupationNot           *string              `json:"occupation_not,omitempty"`
	OccupationIn            []string             `json:"occupation_in,omitempty"`
	OccupationNotIn         []string             `json:"occupation_not_in,omitempty"`
	OccupationLt            *string              `json:"occupation_lt,omitempty"`
	OccupationLte           *string              `json:"occupation_lte,omitempty"`
	OccupationGt            *string              `json:"occupation_gt,omitempty"`
	OccupationGte           *string              `json:"occupation_gte,omitempty"`
	OccupationContains      *string              `json:"occupation_contains,omitempty"`
	OccupationNotContains   *string              `json:"occupation_not_contains,omitempty"`
	OccupationStartsWith    *string              `json:"occupation_starts_with,omitempty"`
	OccupationNotStartsWith *string              `json:"occupation_not_starts_with,omitempty"`
	OccupationEndsWith      *string              `json:"occupation_ends_with,omitempty"`
	OccupationNotEndsWith   *string              `json:"occupation_not_ends_with,omitempty"`
	Address1                *string              `json:"address1,omitempty"`
	Address1Not             *string              `json:"address1_not,omitempty"`
	Address1In              []string             `json:"address1_in,omitempty"`
	Address1NotIn           []string             `json:"address1_not_in,omitempty"`
	Address1Lt              *string              `json:"address1_lt,omitempty"`
	Address1Lte             *string              `json:"address1_lte,omitempty"`
	Address1Gt              *string              `json:"address1_gt,omitempty"`
	Address1Gte             *string              `json:"address1_gte,omitempty"`
	Address1Contains        *string              `json:"address1_contains,omitempty"`
	Address1NotContains     *string              `json:"address1_not_contains,omitempty"`
	Address1StartsWith      *string              `json:"address1_starts_with,omitempty"`
	Address1NotStartsWith   *string              `json:"address1_not_starts_with,omitempty"`
	Address1EndsWith        *string              `json:"address1_ends_with,omitempty"`
	Address1NotEndsWith     *string              `json:"address1_not_ends_with,omitempty"`
	Address2                *string              `json:"address2,omitempty"`
	Address2Not             *string              `json:"address2_not,omitempty"`
	Address2In              []string             `json:"address2_in,omitempty"`
	Address2NotIn           []string             `json:"address2_not_in,omitempty"`
	Address2Lt              *string              `json:"address2_lt,omitempty"`
	Address2Lte             *string              `json:"address2_lte,omitempty"`
	Address2Gt              *string              `json:"address2_gt,omitempty"`
	Address2Gte             *string              `json:"address2_gte,omitempty"`
	Address2Contains        *string              `json:"address2_contains,omitempty"`
	Address2NotContains     *string              `json:"address2_not_contains,omitempty"`
	Address2StartsWith      *string              `json:"address2_starts_with,omitempty"`
	Address2NotStartsWith   *string              `json:"address2_not_starts_with,omitempty"`
	Address2EndsWith        *string              `json:"address2_ends_with,omitempty"`
	Address2NotEndsWith     *string              `json:"address2_not_ends_with,omitempty"`
	Postcode                *string              `json:"postcode,omitempty"`
	PostcodeNot             *string              `json:"postcode_not,omitempty"`
	PostcodeIn              []string             `json:"postcode_in,omitempty"`
	PostcodeNotIn           []string             `json:"postcode_not_in,omitempty"`
	PostcodeLt              *string              `json:"postcode_lt,omitempty"`
	PostcodeLte             *string              `json:"postcode_lte,omitempty"`
	PostcodeGt              *string              `json:"postcode_gt,omitempty"`
	PostcodeGte             *string              `json:"postcode_gte,omitempty"`
	PostcodeContains        *string              `json:"postcode_contains,omitempty"`
	PostcodeNotContains     *string              `json:"postcode_not_contains,omitempty"`
	PostcodeStartsWith      *string              `json:"postcode_starts_with,omitempty"`
	PostcodeNotStartsWith   *string              `json:"postcode_not_starts_with,omitempty"`
	PostcodeEndsWith        *string              `json:"postcode_ends_with,omitempty"`
	PostcodeNotEndsWith     *string              `json:"postcode_not_ends_with,omitempty"`
	Country                 *string              `json:"country,omitempty"`
	CountryNot              *string              `json:"country_not,omitempty"`
	CountryIn               []string             `json:"country_in,omitempty"`
	CountryNotIn            []string             `json:"country_not_in,omitempty"`
	CountryLt               *string              `json:"country_lt,omitempty"`
	CountryLte              *string              `json:"country_lte,omitempty"`
	CountryGt               *string              `json:"country_gt,omitempty"`
	CountryGte              *string              `json:"country_gte,omitempty"`
	CountryContains         *string              `json:"country_contains,omitempty"`
	CountryNotContains      *string              `json:"country_not_contains,omitempty"`
	CountryStartsWith       *string              `json:"country_starts_with,omitempty"`
	CountryNotStartsWith    *string              `json:"country_not_starts_with,omitempty"`
	CountryEndsWith         *string              `json:"country_ends_with,omitempty"`
	CountryNotEndsWith      *string              `json:"country_not_ends_with,omitempty"`
	Agent                   *AgentWhereInput     `json:"agent,omitempty"`
	PropertiesEvery         *PropertyWhereInput  `json:"properties_every,omitempty"`
	PropertiesSome          *PropertyWhereInput  `json:"properties_some,omitempty"`
	PropertiesNone          *PropertyWhereInput  `json:"properties_none,omitempty"`
	And                     []LandlordWhereInput `json:"AND,omitempty"`
	Or                      []LandlordWhereInput `json:"OR,omitempty"`
	Not                     []LandlordWhereInput `json:"NOT,omitempty"`
}

type PropertyUpdateManyWithoutLandlordsInput struct {
	Create     []PropertyCreateWithoutLandlordsInput                `json:"create,omitempty"`
	Delete     []PropertyWhereUniqueInput                           `json:"delete,omitempty"`
	Connect    []PropertyWhereUniqueInput                           `json:"connect,omitempty"`
	Set        []PropertyWhereUniqueInput                           `json:"set,omitempty"`
	Disconnect []PropertyWhereUniqueInput                           `json:"disconnect,omitempty"`
	Update     []PropertyUpdateWithWhereUniqueWithoutLandlordsInput `json:"update,omitempty"`
	Upsert     []PropertyUpsertWithWhereUniqueWithoutLandlordsInput `json:"upsert,omitempty"`
	DeleteMany []PropertyScalarWhereInput                           `json:"deleteMany,omitempty"`
	UpdateMany []PropertyUpdateManyWithWhereNestedInput             `json:"updateMany,omitempty"`
}

type PropertyUpdateManyMutationInput struct {
	Address1              *string `json:"address1,omitempty"`
	Address2              *string `json:"address2,omitempty"`
	Postcode              *string `json:"postcode,omitempty"`
	City                  *string `json:"city,omitempty"`
	Country               *string `json:"country,omitempty"`
	Percentageofownership *int32  `json:"percentageofownership,omitempty"`
	Purchaseprice         *int32  `json:"purchaseprice,omitempty"`
	Currentprice          *int32  `json:"currentprice,omitempty"`
	MortgageAmount        *int32  `json:"mortgageAmount,omitempty"`
	MortgageInterestRate  *int32  `json:"mortgageInterestRate,omitempty"`
	AnnualRentalIncome    *int32  `json:"annualRentalIncome,omitempty"`
	Currency              *string `json:"currency,omitempty"`
}

type PropertyUpdateWithWhereUniqueWithoutLandlordsInput struct {
	Where PropertyWhereUniqueInput                `json:"where"`
	Data  PropertyUpdateWithoutLandlordsDataInput `json:"data"`
}

type TenantWhereUniqueInput struct {
	ID            *string `json:"id,omitempty"`
	PersonalEmail *string `json:"personalEmail,omitempty"`
	WorkEmail     *string `json:"workEmail,omitempty"`
}

type AgentUpdateWithoutClientsDataInput struct {
	BusinessService *string `json:"businessService,omitempty"`
	Title           *string `json:"title,omitempty"`
	FirstName       *string `json:"firstName,omitempty"`
	LastName        *string `json:"lastName,omitempty"`
	DisplayName     *string `json:"displayName,omitempty"`
	Email           *string `json:"email,omitempty"`
	Password        *string `json:"password,omitempty"`
	Mobile          *int32  `json:"mobile,omitempty"`
	Fax             *int32  `json:"fax,omitempty"`
	Address1        *string `json:"address1,omitempty"`
	Address2        *string `json:"address2,omitempty"`
	Postcode        *string `json:"postcode,omitempty"`
	Country         *string `json:"country,omitempty"`
	Website         *string `json:"website,omitempty"`
}

type LandlordUpdateOneWithoutPropertiesInput struct {
	Create     *LandlordCreateWithoutPropertiesInput     `json:"create,omitempty"`
	Update     *LandlordUpdateWithoutPropertiesDataInput `json:"update,omitempty"`
	Upsert     *LandlordUpsertWithoutPropertiesInput     `json:"upsert,omitempty"`
	Delete     *bool                                     `json:"delete,omitempty"`
	Disconnect *bool                                     `json:"disconnect,omitempty"`
	Connect    *LandlordWhereUniqueInput                 `json:"connect,omitempty"`
}

type PropertyStatusUpdateOneRequiredInput struct {
	Create  *PropertyStatusCreateInput       `json:"create,omitempty"`
	Update  *PropertyStatusUpdateDataInput   `json:"update,omitempty"`
	Upsert  *PropertyStatusUpsertNestedInput `json:"upsert,omitempty"`
	Connect *PropertyStatusWhereUniqueInput  `json:"connect,omitempty"`
}

type LandlordCreateWithoutPropertiesInput struct {
	FullName   string                             `json:"fullName"`
	Email      string                             `json:"email"`
	Password   *string                            `json:"password,omitempty"`
	Mobile     *int32                             `json:"mobile,omitempty"`
	Dob        *string                            `json:"dob,omitempty"`
	Occupation *string                            `json:"occupation,omitempty"`
	Address1   *string                            `json:"address1,omitempty"`
	Address2   *string                            `json:"address2,omitempty"`
	Postcode   string                             `json:"postcode"`
	Country    string                             `json:"country"`
	Agent      *AgentCreateOneWithoutClientsInput `json:"agent,omitempty"`
}

type PropertyStatusUpdateDataInput struct {
	Status *string `json:"status,omitempty"`
}

type LandlordCreateOneWithoutPropertiesInput struct {
	Create  *LandlordCreateWithoutPropertiesInput `json:"create,omitempty"`
	Connect *LandlordWhereUniqueInput             `json:"connect,omitempty"`
}

type PropertyStatusUpsertNestedInput struct {
	Update PropertyStatusUpdateDataInput `json:"update"`
	Create PropertyStatusCreateInput     `json:"create"`
}

type LandlordUpdateManyMutationInput struct {
	FullName   *string `json:"fullName,omitempty"`
	Email      *string `json:"email,omitempty"`
	Password   *string `json:"password,omitempty"`
	Mobile     *int32  `json:"mobile,omitempty"`
	Dob        *string `json:"dob,omitempty"`
	Occupation *string `json:"occupation,omitempty"`
	Address1   *string `json:"address1,omitempty"`
	Address2   *string `json:"address2,omitempty"`
	Postcode   *string `json:"postcode,omitempty"`
	Country    *string `json:"country,omitempty"`
}

type PropertyTypeUpdateOneRequiredInput struct {
	Create  *PropertyTypeCreateInput       `json:"create,omitempty"`
	Update  *PropertyTypeUpdateDataInput   `json:"update,omitempty"`
	Upsert  *PropertyTypeUpsertNestedInput `json:"upsert,omitempty"`
	Connect *PropertyTypeWhereUniqueInput  `json:"connect,omitempty"`
}

type LandlordCreateManyWithoutAgentInput struct {
	Create  []LandlordCreateWithoutAgentInput `json:"create,omitempty"`
	Connect []LandlordWhereUniqueInput        `json:"connect,omitempty"`
}

type TenantWhereInput struct {
	ID                         *string              `json:"id,omitempty"`
	IDNot                      *string              `json:"id_not,omitempty"`
	IDIn                       []string             `json:"id_in,omitempty"`
	IDNotIn                    []string             `json:"id_not_in,omitempty"`
	IDLt                       *string              `json:"id_lt,omitempty"`
	IDLte                      *string              `json:"id_lte,omitempty"`
	IDGt                       *string              `json:"id_gt,omitempty"`
	IDGte                      *string              `json:"id_gte,omitempty"`
	IDContains                 *string              `json:"id_contains,omitempty"`
	IDNotContains              *string              `json:"id_not_contains,omitempty"`
	IDStartsWith               *string              `json:"id_starts_with,omitempty"`
	IDNotStartsWith            *string              `json:"id_not_starts_with,omitempty"`
	IDEndsWith                 *string              `json:"id_ends_with,omitempty"`
	IDNotEndsWith              *string              `json:"id_not_ends_with,omitempty"`
	Title                      *string              `json:"title,omitempty"`
	TitleNot                   *string              `json:"title_not,omitempty"`
	TitleIn                    []string             `json:"title_in,omitempty"`
	TitleNotIn                 []string             `json:"title_not_in,omitempty"`
	TitleLt                    *string              `json:"title_lt,omitempty"`
	TitleLte                   *string              `json:"title_lte,omitempty"`
	TitleGt                    *string              `json:"title_gt,omitempty"`
	TitleGte                   *string              `json:"title_gte,omitempty"`
	TitleContains              *string              `json:"title_contains,omitempty"`
	TitleNotContains           *string              `json:"title_not_contains,omitempty"`
	TitleStartsWith            *string              `json:"title_starts_with,omitempty"`
	TitleNotStartsWith         *string              `json:"title_not_starts_with,omitempty"`
	TitleEndsWith              *string              `json:"title_ends_with,omitempty"`
	TitleNotEndsWith           *string              `json:"title_not_ends_with,omitempty"`
	FirstName                  *string              `json:"firstName,omitempty"`
	FirstNameNot               *string              `json:"firstName_not,omitempty"`
	FirstNameIn                []string             `json:"firstName_in,omitempty"`
	FirstNameNotIn             []string             `json:"firstName_not_in,omitempty"`
	FirstNameLt                *string              `json:"firstName_lt,omitempty"`
	FirstNameLte               *string              `json:"firstName_lte,omitempty"`
	FirstNameGt                *string              `json:"firstName_gt,omitempty"`
	FirstNameGte               *string              `json:"firstName_gte,omitempty"`
	FirstNameContains          *string              `json:"firstName_contains,omitempty"`
	FirstNameNotContains       *string              `json:"firstName_not_contains,omitempty"`
	FirstNameStartsWith        *string              `json:"firstName_starts_with,omitempty"`
	FirstNameNotStartsWith     *string              `json:"firstName_not_starts_with,omitempty"`
	FirstNameEndsWith          *string              `json:"firstName_ends_with,omitempty"`
	FirstNameNotEndsWith       *string              `json:"firstName_not_ends_with,omitempty"`
	MiddleName                 *string              `json:"middleName,omitempty"`
	MiddleNameNot              *string              `json:"middleName_not,omitempty"`
	MiddleNameIn               []string             `json:"middleName_in,omitempty"`
	MiddleNameNotIn            []string             `json:"middleName_not_in,omitempty"`
	MiddleNameLt               *string              `json:"middleName_lt,omitempty"`
	MiddleNameLte              *string              `json:"middleName_lte,omitempty"`
	MiddleNameGt               *string              `json:"middleName_gt,omitempty"`
	MiddleNameGte              *string              `json:"middleName_gte,omitempty"`
	MiddleNameContains         *string              `json:"middleName_contains,omitempty"`
	MiddleNameNotContains      *string              `json:"middleName_not_contains,omitempty"`
	MiddleNameStartsWith       *string              `json:"middleName_starts_with,omitempty"`
	MiddleNameNotStartsWith    *string              `json:"middleName_not_starts_with,omitempty"`
	MiddleNameEndsWith         *string              `json:"middleName_ends_with,omitempty"`
	MiddleNameNotEndsWith      *string              `json:"middleName_not_ends_with,omitempty"`
	LastName                   *string              `json:"lastName,omitempty"`
	LastNameNot                *string              `json:"lastName_not,omitempty"`
	LastNameIn                 []string             `json:"lastName_in,omitempty"`
	LastNameNotIn              []string             `json:"lastName_not_in,omitempty"`
	LastNameLt                 *string              `json:"lastName_lt,omitempty"`
	LastNameLte                *string              `json:"lastName_lte,omitempty"`
	LastNameGt                 *string              `json:"lastName_gt,omitempty"`
	LastNameGte                *string              `json:"lastName_gte,omitempty"`
	LastNameContains           *string              `json:"lastName_contains,omitempty"`
	LastNameNotContains        *string              `json:"lastName_not_contains,omitempty"`
	LastNameStartsWith         *string              `json:"lastName_starts_with,omitempty"`
	LastNameNotStartsWith      *string              `json:"lastName_not_starts_with,omitempty"`
	LastNameEndsWith           *string              `json:"lastName_ends_with,omitempty"`
	LastNameNotEndsWith        *string              `json:"lastName_not_ends_with,omitempty"`
	DisplayName                *string              `json:"displayName,omitempty"`
	DisplayNameNot             *string              `json:"displayName_not,omitempty"`
	DisplayNameIn              []string             `json:"displayName_in,omitempty"`
	DisplayNameNotIn           []string             `json:"displayName_not_in,omitempty"`
	DisplayNameLt              *string              `json:"displayName_lt,omitempty"`
	DisplayNameLte             *string              `json:"displayName_lte,omitempty"`
	DisplayNameGt              *string              `json:"displayName_gt,omitempty"`
	DisplayNameGte             *string              `json:"displayName_gte,omitempty"`
	DisplayNameContains        *string              `json:"displayName_contains,omitempty"`
	DisplayNameNotContains     *string              `json:"displayName_not_contains,omitempty"`
	DisplayNameStartsWith      *string              `json:"displayName_starts_with,omitempty"`
	DisplayNameNotStartsWith   *string              `json:"displayName_not_starts_with,omitempty"`
	DisplayNameEndsWith        *string              `json:"displayName_ends_with,omitempty"`
	DisplayNameNotEndsWith     *string              `json:"displayName_not_ends_with,omitempty"`
	PersonalEmail              *string              `json:"personalEmail,omitempty"`
	PersonalEmailNot           *string              `json:"personalEmail_not,omitempty"`
	PersonalEmailIn            []string             `json:"personalEmail_in,omitempty"`
	PersonalEmailNotIn         []string             `json:"personalEmail_not_in,omitempty"`
	PersonalEmailLt            *string              `json:"personalEmail_lt,omitempty"`
	PersonalEmailLte           *string              `json:"personalEmail_lte,omitempty"`
	PersonalEmailGt            *string              `json:"personalEmail_gt,omitempty"`
	PersonalEmailGte           *string              `json:"personalEmail_gte,omitempty"`
	PersonalEmailContains      *string              `json:"personalEmail_contains,omitempty"`
	PersonalEmailNotContains   *string              `json:"personalEmail_not_contains,omitempty"`
	PersonalEmailStartsWith    *string              `json:"personalEmail_starts_with,omitempty"`
	PersonalEmailNotStartsWith *string              `json:"personalEmail_not_starts_with,omitempty"`
	PersonalEmailEndsWith      *string              `json:"personalEmail_ends_with,omitempty"`
	PersonalEmailNotEndsWith   *string              `json:"personalEmail_not_ends_with,omitempty"`
	WorkEmail                  *string              `json:"workEmail,omitempty"`
	WorkEmailNot               *string              `json:"workEmail_not,omitempty"`
	WorkEmailIn                []string             `json:"workEmail_in,omitempty"`
	WorkEmailNotIn             []string             `json:"workEmail_not_in,omitempty"`
	WorkEmailLt                *string              `json:"workEmail_lt,omitempty"`
	WorkEmailLte               *string              `json:"workEmail_lte,omitempty"`
	WorkEmailGt                *string              `json:"workEmail_gt,omitempty"`
	WorkEmailGte               *string              `json:"workEmail_gte,omitempty"`
	WorkEmailContains          *string              `json:"workEmail_contains,omitempty"`
	WorkEmailNotContains       *string              `json:"workEmail_not_contains,omitempty"`
	WorkEmailStartsWith        *string              `json:"workEmail_starts_with,omitempty"`
	WorkEmailNotStartsWith     *string              `json:"workEmail_not_starts_with,omitempty"`
	WorkEmailEndsWith          *string              `json:"workEmail_ends_with,omitempty"`
	WorkEmailNotEndsWith       *string              `json:"workEmail_not_ends_with,omitempty"`
	Homenumber                 *int32               `json:"homenumber,omitempty"`
	HomenumberNot              *int32               `json:"homenumber_not,omitempty"`
	HomenumberIn               []int32              `json:"homenumber_in,omitempty"`
	HomenumberNotIn            []int32              `json:"homenumber_not_in,omitempty"`
	HomenumberLt               *int32               `json:"homenumber_lt,omitempty"`
	HomenumberLte              *int32               `json:"homenumber_lte,omitempty"`
	HomenumberGt               *int32               `json:"homenumber_gt,omitempty"`
	HomenumberGte              *int32               `json:"homenumber_gte,omitempty"`
	Mobilenumber               *int32               `json:"mobilenumber,omitempty"`
	MobilenumberNot            *int32               `json:"mobilenumber_not,omitempty"`
	MobilenumberIn             []int32              `json:"mobilenumber_in,omitempty"`
	MobilenumberNotIn          []int32              `json:"mobilenumber_not_in,omitempty"`
	MobilenumberLt             *int32               `json:"mobilenumber_lt,omitempty"`
	MobilenumberLte            *int32               `json:"mobilenumber_lte,omitempty"`
	MobilenumberGt             *int32               `json:"mobilenumber_gt,omitempty"`
	MobilenumberGte            *int32               `json:"mobilenumber_gte,omitempty"`
	TypeOfLet                  *TypeOfLetWhereInput `json:"typeOfLet,omitempty"`
	RentInterval               *string              `json:"rentInterval,omitempty"`
	RentIntervalNot            *string              `json:"rentInterval_not,omitempty"`
	RentIntervalIn             []string             `json:"rentInterval_in,omitempty"`
	RentIntervalNotIn          []string             `json:"rentInterval_not_in,omitempty"`
	RentIntervalLt             *string              `json:"rentInterval_lt,omitempty"`
	RentIntervalLte            *string              `json:"rentInterval_lte,omitempty"`
	RentIntervalGt             *string              `json:"rentInterval_gt,omitempty"`
	RentIntervalGte            *string              `json:"rentInterval_gte,omitempty"`
	RentIntervalContains       *string              `json:"rentInterval_contains,omitempty"`
	RentIntervalNotContains    *string              `json:"rentInterval_not_contains,omitempty"`
	RentIntervalStartsWith     *string              `json:"rentInterval_starts_with,omitempty"`
	RentIntervalNotStartsWith  *string              `json:"rentInterval_not_starts_with,omitempty"`
	RentIntervalEndsWith       *string              `json:"rentInterval_ends_with,omitempty"`
	RentIntervalNotEndsWith    *string              `json:"rentInterval_not_ends_with,omitempty"`
	Day                        *string              `json:"day,omitempty"`
	DayNot                     *string              `json:"day_not,omitempty"`
	DayIn                      []string             `json:"day_in,omitempty"`
	DayNotIn                   []string             `json:"day_not_in,omitempty"`
	DayLt                      *string              `json:"day_lt,omitempty"`
	DayLte                     *string              `json:"day_lte,omitempty"`
	DayGt                      *string              `json:"day_gt,omitempty"`
	DayGte                     *string              `json:"day_gte,omitempty"`
	DayContains                *string              `json:"day_contains,omitempty"`
	DayNotContains             *string              `json:"day_not_contains,omitempty"`
	DayStartsWith              *string              `json:"day_starts_with,omitempty"`
	DayNotStartsWith           *string              `json:"day_not_starts_with,omitempty"`
	DayEndsWith                *string              `json:"day_ends_with,omitempty"`
	DayNotEndsWith             *string              `json:"day_not_ends_with,omitempty"`
	StartDate                  *string              `json:"startDate,omitempty"`
	StartDateNot               *string              `json:"startDate_not,omitempty"`
	StartDateIn                []string             `json:"startDate_in,omitempty"`
	StartDateNotIn             []string             `json:"startDate_not_in,omitempty"`
	StartDateLt                *string              `json:"startDate_lt,omitempty"`
	StartDateLte               *string              `json:"startDate_lte,omitempty"`
	StartDateGt                *string              `json:"startDate_gt,omitempty"`
	StartDateGte               *string              `json:"startDate_gte,omitempty"`
	EndDate                    *string              `json:"endDate,omitempty"`
	EndDateNot                 *string              `json:"endDate_not,omitempty"`
	EndDateIn                  []string             `json:"endDate_in,omitempty"`
	EndDateNotIn               []string             `json:"endDate_not_in,omitempty"`
	EndDateLt                  *string              `json:"endDate_lt,omitempty"`
	EndDateLte                 *string              `json:"endDate_lte,omitempty"`
	EndDateGt                  *string              `json:"endDate_gt,omitempty"`
	EndDateGte                 *string              `json:"endDate_gte,omitempty"`
	Notes                      *string              `json:"notes,omitempty"`
	NotesNot                   *string              `json:"notes_not,omitempty"`
	NotesIn                    []string             `json:"notes_in,omitempty"`
	NotesNotIn                 []string             `json:"notes_not_in,omitempty"`
	NotesLt                    *string              `json:"notes_lt,omitempty"`
	NotesLte                   *string              `json:"notes_lte,omitempty"`
	NotesGt                    *string              `json:"notes_gt,omitempty"`
	NotesGte                   *string              `json:"notes_gte,omitempty"`
	NotesContains              *string              `json:"notes_contains,omitempty"`
	NotesNotContains           *string              `json:"notes_not_contains,omitempty"`
	NotesStartsWith            *string              `json:"notes_starts_with,omitempty"`
	NotesNotStartsWith         *string              `json:"notes_not_starts_with,omitempty"`
	NotesEndsWith              *string              `json:"notes_ends_with,omitempty"`
	NotesNotEndsWith           *string              `json:"notes_not_ends_with,omitempty"`
	Property                   *PropertyWhereInput  `json:"property,omitempty"`
	And                        []TenantWhereInput   `json:"AND,omitempty"`
	Or                         []TenantWhereInput   `json:"OR,omitempty"`
	Not                        []TenantWhereInput   `json:"NOT,omitempty"`
}

type PropertyTypeSubscriptionWhereInput struct {
	MutationIn                 []MutationType                       `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                              `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                             `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                             `json:"updatedFields_contains_some,omitempty"`
	Node                       *PropertyTypeWhereInput              `json:"node,omitempty"`
	And                        []PropertyTypeSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []PropertyTypeSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []PropertyTypeSubscriptionWhereInput `json:"NOT,omitempty"`
}

type PropertyStatusWhereInput struct {
	ID                  *string                    `json:"id,omitempty"`
	IDNot               *string                    `json:"id_not,omitempty"`
	IDIn                []string                   `json:"id_in,omitempty"`
	IDNotIn             []string                   `json:"id_not_in,omitempty"`
	IDLt                *string                    `json:"id_lt,omitempty"`
	IDLte               *string                    `json:"id_lte,omitempty"`
	IDGt                *string                    `json:"id_gt,omitempty"`
	IDGte               *string                    `json:"id_gte,omitempty"`
	IDContains          *string                    `json:"id_contains,omitempty"`
	IDNotContains       *string                    `json:"id_not_contains,omitempty"`
	IDStartsWith        *string                    `json:"id_starts_with,omitempty"`
	IDNotStartsWith     *string                    `json:"id_not_starts_with,omitempty"`
	IDEndsWith          *string                    `json:"id_ends_with,omitempty"`
	IDNotEndsWith       *string                    `json:"id_not_ends_with,omitempty"`
	Status              *string                    `json:"status,omitempty"`
	StatusNot           *string                    `json:"status_not,omitempty"`
	StatusIn            []string                   `json:"status_in,omitempty"`
	StatusNotIn         []string                   `json:"status_not_in,omitempty"`
	StatusLt            *string                    `json:"status_lt,omitempty"`
	StatusLte           *string                    `json:"status_lte,omitempty"`
	StatusGt            *string                    `json:"status_gt,omitempty"`
	StatusGte           *string                    `json:"status_gte,omitempty"`
	StatusContains      *string                    `json:"status_contains,omitempty"`
	StatusNotContains   *string                    `json:"status_not_contains,omitempty"`
	StatusStartsWith    *string                    `json:"status_starts_with,omitempty"`
	StatusNotStartsWith *string                    `json:"status_not_starts_with,omitempty"`
	StatusEndsWith      *string                    `json:"status_ends_with,omitempty"`
	StatusNotEndsWith   *string                    `json:"status_not_ends_with,omitempty"`
	And                 []PropertyStatusWhereInput `json:"AND,omitempty"`
	Or                  []PropertyStatusWhereInput `json:"OR,omitempty"`
	Not                 []PropertyStatusWhereInput `json:"NOT,omitempty"`
}

type LandlordSubscriptionWhereInput struct {
	MutationIn                 []MutationType                   `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                          `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                         `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                         `json:"updatedFields_contains_some,omitempty"`
	Node                       *LandlordWhereInput              `json:"node,omitempty"`
	And                        []LandlordSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []LandlordSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []LandlordSubscriptionWhereInput `json:"NOT,omitempty"`
}

type PropertyWhereInput struct {
	ID                         *string                   `json:"id,omitempty"`
	IDNot                      *string                   `json:"id_not,omitempty"`
	IDIn                       []string                  `json:"id_in,omitempty"`
	IDNotIn                    []string                  `json:"id_not_in,omitempty"`
	IDLt                       *string                   `json:"id_lt,omitempty"`
	IDLte                      *string                   `json:"id_lte,omitempty"`
	IDGt                       *string                   `json:"id_gt,omitempty"`
	IDGte                      *string                   `json:"id_gte,omitempty"`
	IDContains                 *string                   `json:"id_contains,omitempty"`
	IDNotContains              *string                   `json:"id_not_contains,omitempty"`
	IDStartsWith               *string                   `json:"id_starts_with,omitempty"`
	IDNotStartsWith            *string                   `json:"id_not_starts_with,omitempty"`
	IDEndsWith                 *string                   `json:"id_ends_with,omitempty"`
	IDNotEndsWith              *string                   `json:"id_not_ends_with,omitempty"`
	Address1                   *string                   `json:"address1,omitempty"`
	Address1Not                *string                   `json:"address1_not,omitempty"`
	Address1In                 []string                  `json:"address1_in,omitempty"`
	Address1NotIn              []string                  `json:"address1_not_in,omitempty"`
	Address1Lt                 *string                   `json:"address1_lt,omitempty"`
	Address1Lte                *string                   `json:"address1_lte,omitempty"`
	Address1Gt                 *string                   `json:"address1_gt,omitempty"`
	Address1Gte                *string                   `json:"address1_gte,omitempty"`
	Address1Contains           *string                   `json:"address1_contains,omitempty"`
	Address1NotContains        *string                   `json:"address1_not_contains,omitempty"`
	Address1StartsWith         *string                   `json:"address1_starts_with,omitempty"`
	Address1NotStartsWith      *string                   `json:"address1_not_starts_with,omitempty"`
	Address1EndsWith           *string                   `json:"address1_ends_with,omitempty"`
	Address1NotEndsWith        *string                   `json:"address1_not_ends_with,omitempty"`
	Address2                   *string                   `json:"address2,omitempty"`
	Address2Not                *string                   `json:"address2_not,omitempty"`
	Address2In                 []string                  `json:"address2_in,omitempty"`
	Address2NotIn              []string                  `json:"address2_not_in,omitempty"`
	Address2Lt                 *string                   `json:"address2_lt,omitempty"`
	Address2Lte                *string                   `json:"address2_lte,omitempty"`
	Address2Gt                 *string                   `json:"address2_gt,omitempty"`
	Address2Gte                *string                   `json:"address2_gte,omitempty"`
	Address2Contains           *string                   `json:"address2_contains,omitempty"`
	Address2NotContains        *string                   `json:"address2_not_contains,omitempty"`
	Address2StartsWith         *string                   `json:"address2_starts_with,omitempty"`
	Address2NotStartsWith      *string                   `json:"address2_not_starts_with,omitempty"`
	Address2EndsWith           *string                   `json:"address2_ends_with,omitempty"`
	Address2NotEndsWith        *string                   `json:"address2_not_ends_with,omitempty"`
	Postcode                   *string                   `json:"postcode,omitempty"`
	PostcodeNot                *string                   `json:"postcode_not,omitempty"`
	PostcodeIn                 []string                  `json:"postcode_in,omitempty"`
	PostcodeNotIn              []string                  `json:"postcode_not_in,omitempty"`
	PostcodeLt                 *string                   `json:"postcode_lt,omitempty"`
	PostcodeLte                *string                   `json:"postcode_lte,omitempty"`
	PostcodeGt                 *string                   `json:"postcode_gt,omitempty"`
	PostcodeGte                *string                   `json:"postcode_gte,omitempty"`
	PostcodeContains           *string                   `json:"postcode_contains,omitempty"`
	PostcodeNotContains        *string                   `json:"postcode_not_contains,omitempty"`
	PostcodeStartsWith         *string                   `json:"postcode_starts_with,omitempty"`
	PostcodeNotStartsWith      *string                   `json:"postcode_not_starts_with,omitempty"`
	PostcodeEndsWith           *string                   `json:"postcode_ends_with,omitempty"`
	PostcodeNotEndsWith        *string                   `json:"postcode_not_ends_with,omitempty"`
	City                       *string                   `json:"city,omitempty"`
	CityNot                    *string                   `json:"city_not,omitempty"`
	CityIn                     []string                  `json:"city_in,omitempty"`
	CityNotIn                  []string                  `json:"city_not_in,omitempty"`
	CityLt                     *string                   `json:"city_lt,omitempty"`
	CityLte                    *string                   `json:"city_lte,omitempty"`
	CityGt                     *string                   `json:"city_gt,omitempty"`
	CityGte                    *string                   `json:"city_gte,omitempty"`
	CityContains               *string                   `json:"city_contains,omitempty"`
	CityNotContains            *string                   `json:"city_not_contains,omitempty"`
	CityStartsWith             *string                   `json:"city_starts_with,omitempty"`
	CityNotStartsWith          *string                   `json:"city_not_starts_with,omitempty"`
	CityEndsWith               *string                   `json:"city_ends_with,omitempty"`
	CityNotEndsWith            *string                   `json:"city_not_ends_with,omitempty"`
	Country                    *string                   `json:"country,omitempty"`
	CountryNot                 *string                   `json:"country_not,omitempty"`
	CountryIn                  []string                  `json:"country_in,omitempty"`
	CountryNotIn               []string                  `json:"country_not_in,omitempty"`
	CountryLt                  *string                   `json:"country_lt,omitempty"`
	CountryLte                 *string                   `json:"country_lte,omitempty"`
	CountryGt                  *string                   `json:"country_gt,omitempty"`
	CountryGte                 *string                   `json:"country_gte,omitempty"`
	CountryContains            *string                   `json:"country_contains,omitempty"`
	CountryNotContains         *string                   `json:"country_not_contains,omitempty"`
	CountryStartsWith          *string                   `json:"country_starts_with,omitempty"`
	CountryNotStartsWith       *string                   `json:"country_not_starts_with,omitempty"`
	CountryEndsWith            *string                   `json:"country_ends_with,omitempty"`
	CountryNotEndsWith         *string                   `json:"country_not_ends_with,omitempty"`
	Percentageofownership      *int32                    `json:"percentageofownership,omitempty"`
	PercentageofownershipNot   *int32                    `json:"percentageofownership_not,omitempty"`
	PercentageofownershipIn    []int32                   `json:"percentageofownership_in,omitempty"`
	PercentageofownershipNotIn []int32                   `json:"percentageofownership_not_in,omitempty"`
	PercentageofownershipLt    *int32                    `json:"percentageofownership_lt,omitempty"`
	PercentageofownershipLte   *int32                    `json:"percentageofownership_lte,omitempty"`
	PercentageofownershipGt    *int32                    `json:"percentageofownership_gt,omitempty"`
	PercentageofownershipGte   *int32                    `json:"percentageofownership_gte,omitempty"`
	Status                     *PropertyStatusWhereInput `json:"status,omitempty"`
	Type                       *PropertyTypeWhereInput   `json:"type,omitempty"`
	Purchaseprice              *int32                    `json:"purchaseprice,omitempty"`
	PurchasepriceNot           *int32                    `json:"purchaseprice_not,omitempty"`
	PurchasepriceIn            []int32                   `json:"purchaseprice_in,omitempty"`
	PurchasepriceNotIn         []int32                   `json:"purchaseprice_not_in,omitempty"`
	PurchasepriceLt            *int32                    `json:"purchaseprice_lt,omitempty"`
	PurchasepriceLte           *int32                    `json:"purchaseprice_lte,omitempty"`
	PurchasepriceGt            *int32                    `json:"purchaseprice_gt,omitempty"`
	PurchasepriceGte           *int32                    `json:"purchaseprice_gte,omitempty"`
	Currentprice               *int32                    `json:"currentprice,omitempty"`
	CurrentpriceNot            *int32                    `json:"currentprice_not,omitempty"`
	CurrentpriceIn             []int32                   `json:"currentprice_in,omitempty"`
	CurrentpriceNotIn          []int32                   `json:"currentprice_not_in,omitempty"`
	CurrentpriceLt             *int32                    `json:"currentprice_lt,omitempty"`
	CurrentpriceLte            *int32                    `json:"currentprice_lte,omitempty"`
	CurrentpriceGt             *int32                    `json:"currentprice_gt,omitempty"`
	CurrentpriceGte            *int32                    `json:"currentprice_gte,omitempty"`
	MortgageAmount             *int32                    `json:"mortgageAmount,omitempty"`
	MortgageAmountNot          *int32                    `json:"mortgageAmount_not,omitempty"`
	MortgageAmountIn           []int32                   `json:"mortgageAmount_in,omitempty"`
	MortgageAmountNotIn        []int32                   `json:"mortgageAmount_not_in,omitempty"`
	MortgageAmountLt           *int32                    `json:"mortgageAmount_lt,omitempty"`
	MortgageAmountLte          *int32                    `json:"mortgageAmount_lte,omitempty"`
	MortgageAmountGt           *int32                    `json:"mortgageAmount_gt,omitempty"`
	MortgageAmountGte          *int32                    `json:"mortgageAmount_gte,omitempty"`
	MortgageInterestRate       *int32                    `json:"mortgageInterestRate,omitempty"`
	MortgageInterestRateNot    *int32                    `json:"mortgageInterestRate_not,omitempty"`
	MortgageInterestRateIn     []int32                   `json:"mortgageInterestRate_in,omitempty"`
	MortgageInterestRateNotIn  []int32                   `json:"mortgageInterestRate_not_in,omitempty"`
	MortgageInterestRateLt     *int32                    `json:"mortgageInterestRate_lt,omitempty"`
	MortgageInterestRateLte    *int32                    `json:"mortgageInterestRate_lte,omitempty"`
	MortgageInterestRateGt     *int32                    `json:"mortgageInterestRate_gt,omitempty"`
	MortgageInterestRateGte    *int32                    `json:"mortgageInterestRate_gte,omitempty"`
	AnnualRentalIncome         *int32                    `json:"annualRentalIncome,omitempty"`
	AnnualRentalIncomeNot      *int32                    `json:"annualRentalIncome_not,omitempty"`
	AnnualRentalIncomeIn       []int32                   `json:"annualRentalIncome_in,omitempty"`
	AnnualRentalIncomeNotIn    []int32                   `json:"annualRentalIncome_not_in,omitempty"`
	AnnualRentalIncomeLt       *int32                    `json:"annualRentalIncome_lt,omitempty"`
	AnnualRentalIncomeLte      *int32                    `json:"annualRentalIncome_lte,omitempty"`
	AnnualRentalIncomeGt       *int32                    `json:"annualRentalIncome_gt,omitempty"`
	AnnualRentalIncomeGte      *int32                    `json:"annualRentalIncome_gte,omitempty"`
	Currency                   *string                   `json:"currency,omitempty"`
	CurrencyNot                *string                   `json:"currency_not,omitempty"`
	CurrencyIn                 []string                  `json:"currency_in,omitempty"`
	CurrencyNotIn              []string                  `json:"currency_not_in,omitempty"`
	CurrencyLt                 *string                   `json:"currency_lt,omitempty"`
	CurrencyLte                *string                   `json:"currency_lte,omitempty"`
	CurrencyGt                 *string                   `json:"currency_gt,omitempty"`
	CurrencyGte                *string                   `json:"currency_gte,omitempty"`
	CurrencyContains           *string                   `json:"currency_contains,omitempty"`
	CurrencyNotContains        *string                   `json:"currency_not_contains,omitempty"`
	CurrencyStartsWith         *string                   `json:"currency_starts_with,omitempty"`
	CurrencyNotStartsWith      *string                   `json:"currency_not_starts_with,omitempty"`
	CurrencyEndsWith           *string                   `json:"currency_ends_with,omitempty"`
	CurrencyNotEndsWith        *string                   `json:"currency_not_ends_with,omitempty"`
	Tenants                    *TenantWhereInput         `json:"tenants,omitempty"`
	Landlords                  *LandlordWhereInput       `json:"landlords,omitempty"`
	And                        []PropertyWhereInput      `json:"AND,omitempty"`
	Or                         []PropertyWhereInput      `json:"OR,omitempty"`
	Not                        []PropertyWhereInput      `json:"NOT,omitempty"`
}

type TenantUpdateManyMutationInput struct {
	Title         *string `json:"title,omitempty"`
	FirstName     *string `json:"firstName,omitempty"`
	MiddleName    *string `json:"middleName,omitempty"`
	LastName      *string `json:"lastName,omitempty"`
	DisplayName   *string `json:"displayName,omitempty"`
	PersonalEmail *string `json:"personalEmail,omitempty"`
	WorkEmail     *string `json:"workEmail,omitempty"`
	Homenumber    *int32  `json:"homenumber,omitempty"`
	Mobilenumber  *int32  `json:"mobilenumber,omitempty"`
	RentInterval  *string `json:"rentInterval,omitempty"`
	Day           *string `json:"day,omitempty"`
	StartDate     *string `json:"startDate,omitempty"`
	EndDate       *string `json:"endDate,omitempty"`
	Notes         *string `json:"notes,omitempty"`
}

type TenantUpdateWithoutPropertyDataInput struct {
	Title         *string                          `json:"title,omitempty"`
	FirstName     *string                          `json:"firstName,omitempty"`
	MiddleName    *string                          `json:"middleName,omitempty"`
	LastName      *string                          `json:"lastName,omitempty"`
	DisplayName   *string                          `json:"displayName,omitempty"`
	PersonalEmail *string                          `json:"personalEmail,omitempty"`
	WorkEmail     *string                          `json:"workEmail,omitempty"`
	Homenumber    *int32                           `json:"homenumber,omitempty"`
	Mobilenumber  *int32                           `json:"mobilenumber,omitempty"`
	TypeOfLet     *TypeOfLetUpdateOneRequiredInput `json:"typeOfLet,omitempty"`
	RentInterval  *string                          `json:"rentInterval,omitempty"`
	Day           *string                          `json:"day,omitempty"`
	StartDate     *string                          `json:"startDate,omitempty"`
	EndDate       *string                          `json:"endDate,omitempty"`
	Notes         *string                          `json:"notes,omitempty"`
}

type PropertyUpdateOneWithoutTenantsInput struct {
	Create     *PropertyCreateWithoutTenantsInput     `json:"create,omitempty"`
	Update     *PropertyUpdateWithoutTenantsDataInput `json:"update,omitempty"`
	Upsert     *PropertyUpsertWithoutTenantsInput     `json:"upsert,omitempty"`
	Delete     *bool                                  `json:"delete,omitempty"`
	Disconnect *bool                                  `json:"disconnect,omitempty"`
	Connect    *PropertyWhereUniqueInput              `json:"connect,omitempty"`
}

type TypeOfLetUpdateOneRequiredInput struct {
	Create  *TypeOfLetCreateInput       `json:"create,omitempty"`
	Update  *TypeOfLetUpdateDataInput   `json:"update,omitempty"`
	Upsert  *TypeOfLetUpsertNestedInput `json:"upsert,omitempty"`
	Connect *TypeOfLetWhereUniqueInput  `json:"connect,omitempty"`
}

type PropertyCreateOneWithoutTenantsInput struct {
	Create  *PropertyCreateWithoutTenantsInput `json:"create,omitempty"`
	Connect *PropertyWhereUniqueInput          `json:"connect,omitempty"`
}

type TypeOfLetUpdateDataInput struct {
	Name *string `json:"name,omitempty"`
}

type PropertyTypeUpdateInput struct {
	Type *string `json:"type,omitempty"`
}

type TypeOfLetUpsertNestedInput struct {
	Update TypeOfLetUpdateDataInput `json:"update"`
	Create TypeOfLetCreateInput     `json:"create"`
}

type PropertyStatusUpdateInput struct {
	Status *string `json:"status,omitempty"`
}

type TenantUpsertWithoutPropertyInput struct {
	Update TenantUpdateWithoutPropertyDataInput `json:"update"`
	Create TenantCreateWithoutPropertyInput     `json:"create"`
}

type LandlordUpdateWithoutPropertiesDataInput struct {
	FullName   *string                            `json:"fullName,omitempty"`
	Email      *string                            `json:"email,omitempty"`
	Password   *string                            `json:"password,omitempty"`
	Mobile     *int32                             `json:"mobile,omitempty"`
	Dob        *string                            `json:"dob,omitempty"`
	Occupation *string                            `json:"occupation,omitempty"`
	Address1   *string                            `json:"address1,omitempty"`
	Address2   *string                            `json:"address2,omitempty"`
	Postcode   *string                            `json:"postcode,omitempty"`
	Country    *string                            `json:"country,omitempty"`
	Agent      *AgentUpdateOneWithoutClientsInput `json:"agent,omitempty"`
}

type PropertyUpsertWithWhereUniqueWithoutLandlordsInput struct {
	Where  PropertyWhereUniqueInput                `json:"where"`
	Update PropertyUpdateWithoutLandlordsDataInput `json:"update"`
	Create PropertyCreateWithoutLandlordsInput     `json:"create"`
}

type TypeOfLetWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type PropertyScalarWhereInput struct {
	ID                         *string                    `json:"id,omitempty"`
	IDNot                      *string                    `json:"id_not,omitempty"`
	IDIn                       []string                   `json:"id_in,omitempty"`
	IDNotIn                    []string                   `json:"id_not_in,omitempty"`
	IDLt                       *string                    `json:"id_lt,omitempty"`
	IDLte                      *string                    `json:"id_lte,omitempty"`
	IDGt                       *string                    `json:"id_gt,omitempty"`
	IDGte                      *string                    `json:"id_gte,omitempty"`
	IDContains                 *string                    `json:"id_contains,omitempty"`
	IDNotContains              *string                    `json:"id_not_contains,omitempty"`
	IDStartsWith               *string                    `json:"id_starts_with,omitempty"`
	IDNotStartsWith            *string                    `json:"id_not_starts_with,omitempty"`
	IDEndsWith                 *string                    `json:"id_ends_with,omitempty"`
	IDNotEndsWith              *string                    `json:"id_not_ends_with,omitempty"`
	Address1                   *string                    `json:"address1,omitempty"`
	Address1Not                *string                    `json:"address1_not,omitempty"`
	Address1In                 []string                   `json:"address1_in,omitempty"`
	Address1NotIn              []string                   `json:"address1_not_in,omitempty"`
	Address1Lt                 *string                    `json:"address1_lt,omitempty"`
	Address1Lte                *string                    `json:"address1_lte,omitempty"`
	Address1Gt                 *string                    `json:"address1_gt,omitempty"`
	Address1Gte                *string                    `json:"address1_gte,omitempty"`
	Address1Contains           *string                    `json:"address1_contains,omitempty"`
	Address1NotContains        *string                    `json:"address1_not_contains,omitempty"`
	Address1StartsWith         *string                    `json:"address1_starts_with,omitempty"`
	Address1NotStartsWith      *string                    `json:"address1_not_starts_with,omitempty"`
	Address1EndsWith           *string                    `json:"address1_ends_with,omitempty"`
	Address1NotEndsWith        *string                    `json:"address1_not_ends_with,omitempty"`
	Address2                   *string                    `json:"address2,omitempty"`
	Address2Not                *string                    `json:"address2_not,omitempty"`
	Address2In                 []string                   `json:"address2_in,omitempty"`
	Address2NotIn              []string                   `json:"address2_not_in,omitempty"`
	Address2Lt                 *string                    `json:"address2_lt,omitempty"`
	Address2Lte                *string                    `json:"address2_lte,omitempty"`
	Address2Gt                 *string                    `json:"address2_gt,omitempty"`
	Address2Gte                *string                    `json:"address2_gte,omitempty"`
	Address2Contains           *string                    `json:"address2_contains,omitempty"`
	Address2NotContains        *string                    `json:"address2_not_contains,omitempty"`
	Address2StartsWith         *string                    `json:"address2_starts_with,omitempty"`
	Address2NotStartsWith      *string                    `json:"address2_not_starts_with,omitempty"`
	Address2EndsWith           *string                    `json:"address2_ends_with,omitempty"`
	Address2NotEndsWith        *string                    `json:"address2_not_ends_with,omitempty"`
	Postcode                   *string                    `json:"postcode,omitempty"`
	PostcodeNot                *string                    `json:"postcode_not,omitempty"`
	PostcodeIn                 []string                   `json:"postcode_in,omitempty"`
	PostcodeNotIn              []string                   `json:"postcode_not_in,omitempty"`
	PostcodeLt                 *string                    `json:"postcode_lt,omitempty"`
	PostcodeLte                *string                    `json:"postcode_lte,omitempty"`
	PostcodeGt                 *string                    `json:"postcode_gt,omitempty"`
	PostcodeGte                *string                    `json:"postcode_gte,omitempty"`
	PostcodeContains           *string                    `json:"postcode_contains,omitempty"`
	PostcodeNotContains        *string                    `json:"postcode_not_contains,omitempty"`
	PostcodeStartsWith         *string                    `json:"postcode_starts_with,omitempty"`
	PostcodeNotStartsWith      *string                    `json:"postcode_not_starts_with,omitempty"`
	PostcodeEndsWith           *string                    `json:"postcode_ends_with,omitempty"`
	PostcodeNotEndsWith        *string                    `json:"postcode_not_ends_with,omitempty"`
	City                       *string                    `json:"city,omitempty"`
	CityNot                    *string                    `json:"city_not,omitempty"`
	CityIn                     []string                   `json:"city_in,omitempty"`
	CityNotIn                  []string                   `json:"city_not_in,omitempty"`
	CityLt                     *string                    `json:"city_lt,omitempty"`
	CityLte                    *string                    `json:"city_lte,omitempty"`
	CityGt                     *string                    `json:"city_gt,omitempty"`
	CityGte                    *string                    `json:"city_gte,omitempty"`
	CityContains               *string                    `json:"city_contains,omitempty"`
	CityNotContains            *string                    `json:"city_not_contains,omitempty"`
	CityStartsWith             *string                    `json:"city_starts_with,omitempty"`
	CityNotStartsWith          *string                    `json:"city_not_starts_with,omitempty"`
	CityEndsWith               *string                    `json:"city_ends_with,omitempty"`
	CityNotEndsWith            *string                    `json:"city_not_ends_with,omitempty"`
	Country                    *string                    `json:"country,omitempty"`
	CountryNot                 *string                    `json:"country_not,omitempty"`
	CountryIn                  []string                   `json:"country_in,omitempty"`
	CountryNotIn               []string                   `json:"country_not_in,omitempty"`
	CountryLt                  *string                    `json:"country_lt,omitempty"`
	CountryLte                 *string                    `json:"country_lte,omitempty"`
	CountryGt                  *string                    `json:"country_gt,omitempty"`
	CountryGte                 *string                    `json:"country_gte,omitempty"`
	CountryContains            *string                    `json:"country_contains,omitempty"`
	CountryNotContains         *string                    `json:"country_not_contains,omitempty"`
	CountryStartsWith          *string                    `json:"country_starts_with,omitempty"`
	CountryNotStartsWith       *string                    `json:"country_not_starts_with,omitempty"`
	CountryEndsWith            *string                    `json:"country_ends_with,omitempty"`
	CountryNotEndsWith         *string                    `json:"country_not_ends_with,omitempty"`
	Percentageofownership      *int32                     `json:"percentageofownership,omitempty"`
	PercentageofownershipNot   *int32                     `json:"percentageofownership_not,omitempty"`
	PercentageofownershipIn    []int32                    `json:"percentageofownership_in,omitempty"`
	PercentageofownershipNotIn []int32                    `json:"percentageofownership_not_in,omitempty"`
	PercentageofownershipLt    *int32                     `json:"percentageofownership_lt,omitempty"`
	PercentageofownershipLte   *int32                     `json:"percentageofownership_lte,omitempty"`
	PercentageofownershipGt    *int32                     `json:"percentageofownership_gt,omitempty"`
	PercentageofownershipGte   *int32                     `json:"percentageofownership_gte,omitempty"`
	Purchaseprice              *int32                     `json:"purchaseprice,omitempty"`
	PurchasepriceNot           *int32                     `json:"purchaseprice_not,omitempty"`
	PurchasepriceIn            []int32                    `json:"purchaseprice_in,omitempty"`
	PurchasepriceNotIn         []int32                    `json:"purchaseprice_not_in,omitempty"`
	PurchasepriceLt            *int32                     `json:"purchaseprice_lt,omitempty"`
	PurchasepriceLte           *int32                     `json:"purchaseprice_lte,omitempty"`
	PurchasepriceGt            *int32                     `json:"purchaseprice_gt,omitempty"`
	PurchasepriceGte           *int32                     `json:"purchaseprice_gte,omitempty"`
	Currentprice               *int32                     `json:"currentprice,omitempty"`
	CurrentpriceNot            *int32                     `json:"currentprice_not,omitempty"`
	CurrentpriceIn             []int32                    `json:"currentprice_in,omitempty"`
	CurrentpriceNotIn          []int32                    `json:"currentprice_not_in,omitempty"`
	CurrentpriceLt             *int32                     `json:"currentprice_lt,omitempty"`
	CurrentpriceLte            *int32                     `json:"currentprice_lte,omitempty"`
	CurrentpriceGt             *int32                     `json:"currentprice_gt,omitempty"`
	CurrentpriceGte            *int32                     `json:"currentprice_gte,omitempty"`
	MortgageAmount             *int32                     `json:"mortgageAmount,omitempty"`
	MortgageAmountNot          *int32                     `json:"mortgageAmount_not,omitempty"`
	MortgageAmountIn           []int32                    `json:"mortgageAmount_in,omitempty"`
	MortgageAmountNotIn        []int32                    `json:"mortgageAmount_not_in,omitempty"`
	MortgageAmountLt           *int32                     `json:"mortgageAmount_lt,omitempty"`
	MortgageAmountLte          *int32                     `json:"mortgageAmount_lte,omitempty"`
	MortgageAmountGt           *int32                     `json:"mortgageAmount_gt,omitempty"`
	MortgageAmountGte          *int32                     `json:"mortgageAmount_gte,omitempty"`
	MortgageInterestRate       *int32                     `json:"mortgageInterestRate,omitempty"`
	MortgageInterestRateNot    *int32                     `json:"mortgageInterestRate_not,omitempty"`
	MortgageInterestRateIn     []int32                    `json:"mortgageInterestRate_in,omitempty"`
	MortgageInterestRateNotIn  []int32                    `json:"mortgageInterestRate_not_in,omitempty"`
	MortgageInterestRateLt     *int32                     `json:"mortgageInterestRate_lt,omitempty"`
	MortgageInterestRateLte    *int32                     `json:"mortgageInterestRate_lte,omitempty"`
	MortgageInterestRateGt     *int32                     `json:"mortgageInterestRate_gt,omitempty"`
	MortgageInterestRateGte    *int32                     `json:"mortgageInterestRate_gte,omitempty"`
	AnnualRentalIncome         *int32                     `json:"annualRentalIncome,omitempty"`
	AnnualRentalIncomeNot      *int32                     `json:"annualRentalIncome_not,omitempty"`
	AnnualRentalIncomeIn       []int32                    `json:"annualRentalIncome_in,omitempty"`
	AnnualRentalIncomeNotIn    []int32                    `json:"annualRentalIncome_not_in,omitempty"`
	AnnualRentalIncomeLt       *int32                     `json:"annualRentalIncome_lt,omitempty"`
	AnnualRentalIncomeLte      *int32                     `json:"annualRentalIncome_lte,omitempty"`
	AnnualRentalIncomeGt       *int32                     `json:"annualRentalIncome_gt,omitempty"`
	AnnualRentalIncomeGte      *int32                     `json:"annualRentalIncome_gte,omitempty"`
	Currency                   *string                    `json:"currency,omitempty"`
	CurrencyNot                *string                    `json:"currency_not,omitempty"`
	CurrencyIn                 []string                   `json:"currency_in,omitempty"`
	CurrencyNotIn              []string                   `json:"currency_not_in,omitempty"`
	CurrencyLt                 *string                    `json:"currency_lt,omitempty"`
	CurrencyLte                *string                    `json:"currency_lte,omitempty"`
	CurrencyGt                 *string                    `json:"currency_gt,omitempty"`
	CurrencyGte                *string                    `json:"currency_gte,omitempty"`
	CurrencyContains           *string                    `json:"currency_contains,omitempty"`
	CurrencyNotContains        *string                    `json:"currency_not_contains,omitempty"`
	CurrencyStartsWith         *string                    `json:"currency_starts_with,omitempty"`
	CurrencyNotStartsWith      *string                    `json:"currency_not_starts_with,omitempty"`
	CurrencyEndsWith           *string                    `json:"currency_ends_with,omitempty"`
	CurrencyNotEndsWith        *string                    `json:"currency_not_ends_with,omitempty"`
	And                        []PropertyScalarWhereInput `json:"AND,omitempty"`
	Or                         []PropertyScalarWhereInput `json:"OR,omitempty"`
	Not                        []PropertyScalarWhereInput `json:"NOT,omitempty"`
}

type AgentUpsertWithoutClientsInput struct {
	Update AgentUpdateWithoutClientsDataInput `json:"update"`
	Create AgentCreateWithoutClientsInput     `json:"create"`
}

type PropertyUpdateManyWithWhereNestedInput struct {
	Where PropertyScalarWhereInput    `json:"where"`
	Data  PropertyUpdateManyDataInput `json:"data"`
}

type TypeOfLetSubscriptionWhereInput struct {
	MutationIn                 []MutationType                    `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                           `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                          `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                          `json:"updatedFields_contains_some,omitempty"`
	Node                       *TypeOfLetWhereInput              `json:"node,omitempty"`
	And                        []TypeOfLetSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []TypeOfLetSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []TypeOfLetSubscriptionWhereInput `json:"NOT,omitempty"`
}

type PropertyUpdateManyDataInput struct {
	Address1              *string `json:"address1,omitempty"`
	Address2              *string `json:"address2,omitempty"`
	Postcode              *string `json:"postcode,omitempty"`
	City                  *string `json:"city,omitempty"`
	Country               *string `json:"country,omitempty"`
	Percentageofownership *int32  `json:"percentageofownership,omitempty"`
	Purchaseprice         *int32  `json:"purchaseprice,omitempty"`
	Currentprice          *int32  `json:"currentprice,omitempty"`
	MortgageAmount        *int32  `json:"mortgageAmount,omitempty"`
	MortgageInterestRate  *int32  `json:"mortgageInterestRate,omitempty"`
	AnnualRentalIncome    *int32  `json:"annualRentalIncome,omitempty"`
	Currency              *string `json:"currency,omitempty"`
}

type TypeOfLetUpdateManyMutationInput struct {
	Name *string `json:"name,omitempty"`
}

type LandlordUpsertWithWhereUniqueWithoutAgentInput struct {
	Where  LandlordWhereUniqueInput            `json:"where"`
	Update LandlordUpdateWithoutAgentDataInput `json:"update"`
	Create LandlordCreateWithoutAgentInput     `json:"create"`
}

type TenantUpdateInput struct {
	Title         *string                               `json:"title,omitempty"`
	FirstName     *string                               `json:"firstName,omitempty"`
	MiddleName    *string                               `json:"middleName,omitempty"`
	LastName      *string                               `json:"lastName,omitempty"`
	DisplayName   *string                               `json:"displayName,omitempty"`
	PersonalEmail *string                               `json:"personalEmail,omitempty"`
	WorkEmail     *string                               `json:"workEmail,omitempty"`
	Homenumber    *int32                                `json:"homenumber,omitempty"`
	Mobilenumber  *int32                                `json:"mobilenumber,omitempty"`
	TypeOfLet     *TypeOfLetUpdateOneRequiredInput      `json:"typeOfLet,omitempty"`
	RentInterval  *string                               `json:"rentInterval,omitempty"`
	Day           *string                               `json:"day,omitempty"`
	StartDate     *string                               `json:"startDate,omitempty"`
	EndDate       *string                               `json:"endDate,omitempty"`
	Notes         *string                               `json:"notes,omitempty"`
	Property      *PropertyUpdateOneWithoutTenantsInput `json:"property,omitempty"`
}

type LandlordScalarWhereInput struct {
	ID                      *string                    `json:"id,omitempty"`
	IDNot                   *string                    `json:"id_not,omitempty"`
	IDIn                    []string                   `json:"id_in,omitempty"`
	IDNotIn                 []string                   `json:"id_not_in,omitempty"`
	IDLt                    *string                    `json:"id_lt,omitempty"`
	IDLte                   *string                    `json:"id_lte,omitempty"`
	IDGt                    *string                    `json:"id_gt,omitempty"`
	IDGte                   *string                    `json:"id_gte,omitempty"`
	IDContains              *string                    `json:"id_contains,omitempty"`
	IDNotContains           *string                    `json:"id_not_contains,omitempty"`
	IDStartsWith            *string                    `json:"id_starts_with,omitempty"`
	IDNotStartsWith         *string                    `json:"id_not_starts_with,omitempty"`
	IDEndsWith              *string                    `json:"id_ends_with,omitempty"`
	IDNotEndsWith           *string                    `json:"id_not_ends_with,omitempty"`
	FullName                *string                    `json:"fullName,omitempty"`
	FullNameNot             *string                    `json:"fullName_not,omitempty"`
	FullNameIn              []string                   `json:"fullName_in,omitempty"`
	FullNameNotIn           []string                   `json:"fullName_not_in,omitempty"`
	FullNameLt              *string                    `json:"fullName_lt,omitempty"`
	FullNameLte             *string                    `json:"fullName_lte,omitempty"`
	FullNameGt              *string                    `json:"fullName_gt,omitempty"`
	FullNameGte             *string                    `json:"fullName_gte,omitempty"`
	FullNameContains        *string                    `json:"fullName_contains,omitempty"`
	FullNameNotContains     *string                    `json:"fullName_not_contains,omitempty"`
	FullNameStartsWith      *string                    `json:"fullName_starts_with,omitempty"`
	FullNameNotStartsWith   *string                    `json:"fullName_not_starts_with,omitempty"`
	FullNameEndsWith        *string                    `json:"fullName_ends_with,omitempty"`
	FullNameNotEndsWith     *string                    `json:"fullName_not_ends_with,omitempty"`
	Email                   *string                    `json:"email,omitempty"`
	EmailNot                *string                    `json:"email_not,omitempty"`
	EmailIn                 []string                   `json:"email_in,omitempty"`
	EmailNotIn              []string                   `json:"email_not_in,omitempty"`
	EmailLt                 *string                    `json:"email_lt,omitempty"`
	EmailLte                *string                    `json:"email_lte,omitempty"`
	EmailGt                 *string                    `json:"email_gt,omitempty"`
	EmailGte                *string                    `json:"email_gte,omitempty"`
	EmailContains           *string                    `json:"email_contains,omitempty"`
	EmailNotContains        *string                    `json:"email_not_contains,omitempty"`
	EmailStartsWith         *string                    `json:"email_starts_with,omitempty"`
	EmailNotStartsWith      *string                    `json:"email_not_starts_with,omitempty"`
	EmailEndsWith           *string                    `json:"email_ends_with,omitempty"`
	EmailNotEndsWith        *string                    `json:"email_not_ends_with,omitempty"`
	Password                *string                    `json:"password,omitempty"`
	PasswordNot             *string                    `json:"password_not,omitempty"`
	PasswordIn              []string                   `json:"password_in,omitempty"`
	PasswordNotIn           []string                   `json:"password_not_in,omitempty"`
	PasswordLt              *string                    `json:"password_lt,omitempty"`
	PasswordLte             *string                    `json:"password_lte,omitempty"`
	PasswordGt              *string                    `json:"password_gt,omitempty"`
	PasswordGte             *string                    `json:"password_gte,omitempty"`
	PasswordContains        *string                    `json:"password_contains,omitempty"`
	PasswordNotContains     *string                    `json:"password_not_contains,omitempty"`
	PasswordStartsWith      *string                    `json:"password_starts_with,omitempty"`
	PasswordNotStartsWith   *string                    `json:"password_not_starts_with,omitempty"`
	PasswordEndsWith        *string                    `json:"password_ends_with,omitempty"`
	PasswordNotEndsWith     *string                    `json:"password_not_ends_with,omitempty"`
	Mobile                  *int32                     `json:"mobile,omitempty"`
	MobileNot               *int32                     `json:"mobile_not,omitempty"`
	MobileIn                []int32                    `json:"mobile_in,omitempty"`
	MobileNotIn             []int32                    `json:"mobile_not_in,omitempty"`
	MobileLt                *int32                     `json:"mobile_lt,omitempty"`
	MobileLte               *int32                     `json:"mobile_lte,omitempty"`
	MobileGt                *int32                     `json:"mobile_gt,omitempty"`
	MobileGte               *int32                     `json:"mobile_gte,omitempty"`
	Dob                     *string                    `json:"dob,omitempty"`
	DobNot                  *string                    `json:"dob_not,omitempty"`
	DobIn                   []string                   `json:"dob_in,omitempty"`
	DobNotIn                []string                   `json:"dob_not_in,omitempty"`
	DobLt                   *string                    `json:"dob_lt,omitempty"`
	DobLte                  *string                    `json:"dob_lte,omitempty"`
	DobGt                   *string                    `json:"dob_gt,omitempty"`
	DobGte                  *string                    `json:"dob_gte,omitempty"`
	Occupation              *string                    `json:"occupation,omitempty"`
	OccupationNot           *string                    `json:"occupation_not,omitempty"`
	OccupationIn            []string                   `json:"occupation_in,omitempty"`
	OccupationNotIn         []string                   `json:"occupation_not_in,omitempty"`
	OccupationLt            *string                    `json:"occupation_lt,omitempty"`
	OccupationLte           *string                    `json:"occupation_lte,omitempty"`
	OccupationGt            *string                    `json:"occupation_gt,omitempty"`
	OccupationGte           *string                    `json:"occupation_gte,omitempty"`
	OccupationContains      *string                    `json:"occupation_contains,omitempty"`
	OccupationNotContains   *string                    `json:"occupation_not_contains,omitempty"`
	OccupationStartsWith    *string                    `json:"occupation_starts_with,omitempty"`
	OccupationNotStartsWith *string                    `json:"occupation_not_starts_with,omitempty"`
	OccupationEndsWith      *string                    `json:"occupation_ends_with,omitempty"`
	OccupationNotEndsWith   *string                    `json:"occupation_not_ends_with,omitempty"`
	Address1                *string                    `json:"address1,omitempty"`
	Address1Not             *string                    `json:"address1_not,omitempty"`
	Address1In              []string                   `json:"address1_in,omitempty"`
	Address1NotIn           []string                   `json:"address1_not_in,omitempty"`
	Address1Lt              *string                    `json:"address1_lt,omitempty"`
	Address1Lte             *string                    `json:"address1_lte,omitempty"`
	Address1Gt              *string                    `json:"address1_gt,omitempty"`
	Address1Gte             *string                    `json:"address1_gte,omitempty"`
	Address1Contains        *string                    `json:"address1_contains,omitempty"`
	Address1NotContains     *string                    `json:"address1_not_contains,omitempty"`
	Address1StartsWith      *string                    `json:"address1_starts_with,omitempty"`
	Address1NotStartsWith   *string                    `json:"address1_not_starts_with,omitempty"`
	Address1EndsWith        *string                    `json:"address1_ends_with,omitempty"`
	Address1NotEndsWith     *string                    `json:"address1_not_ends_with,omitempty"`
	Address2                *string                    `json:"address2,omitempty"`
	Address2Not             *string                    `json:"address2_not,omitempty"`
	Address2In              []string                   `json:"address2_in,omitempty"`
	Address2NotIn           []string                   `json:"address2_not_in,omitempty"`
	Address2Lt              *string                    `json:"address2_lt,omitempty"`
	Address2Lte             *string                    `json:"address2_lte,omitempty"`
	Address2Gt              *string                    `json:"address2_gt,omitempty"`
	Address2Gte             *string                    `json:"address2_gte,omitempty"`
	Address2Contains        *string                    `json:"address2_contains,omitempty"`
	Address2NotContains     *string                    `json:"address2_not_contains,omitempty"`
	Address2StartsWith      *string                    `json:"address2_starts_with,omitempty"`
	Address2NotStartsWith   *string                    `json:"address2_not_starts_with,omitempty"`
	Address2EndsWith        *string                    `json:"address2_ends_with,omitempty"`
	Address2NotEndsWith     *string                    `json:"address2_not_ends_with,omitempty"`
	Postcode                *string                    `json:"postcode,omitempty"`
	PostcodeNot             *string                    `json:"postcode_not,omitempty"`
	PostcodeIn              []string                   `json:"postcode_in,omitempty"`
	PostcodeNotIn           []string                   `json:"postcode_not_in,omitempty"`
	PostcodeLt              *string                    `json:"postcode_lt,omitempty"`
	PostcodeLte             *string                    `json:"postcode_lte,omitempty"`
	PostcodeGt              *string                    `json:"postcode_gt,omitempty"`
	PostcodeGte             *string                    `json:"postcode_gte,omitempty"`
	PostcodeContains        *string                    `json:"postcode_contains,omitempty"`
	PostcodeNotContains     *string                    `json:"postcode_not_contains,omitempty"`
	PostcodeStartsWith      *string                    `json:"postcode_starts_with,omitempty"`
	PostcodeNotStartsWith   *string                    `json:"postcode_not_starts_with,omitempty"`
	PostcodeEndsWith        *string                    `json:"postcode_ends_with,omitempty"`
	PostcodeNotEndsWith     *string                    `json:"postcode_not_ends_with,omitempty"`
	Country                 *string                    `json:"country,omitempty"`
	CountryNot              *string                    `json:"country_not,omitempty"`
	CountryIn               []string                   `json:"country_in,omitempty"`
	CountryNotIn            []string                   `json:"country_not_in,omitempty"`
	CountryLt               *string                    `json:"country_lt,omitempty"`
	CountryLte              *string                    `json:"country_lte,omitempty"`
	CountryGt               *string                    `json:"country_gt,omitempty"`
	CountryGte              *string                    `json:"country_gte,omitempty"`
	CountryContains         *string                    `json:"country_contains,omitempty"`
	CountryNotContains      *string                    `json:"country_not_contains,omitempty"`
	CountryStartsWith       *string                    `json:"country_starts_with,omitempty"`
	CountryNotStartsWith    *string                    `json:"country_not_starts_with,omitempty"`
	CountryEndsWith         *string                    `json:"country_ends_with,omitempty"`
	CountryNotEndsWith      *string                    `json:"country_not_ends_with,omitempty"`
	And                     []LandlordScalarWhereInput `json:"AND,omitempty"`
	Or                      []LandlordScalarWhereInput `json:"OR,omitempty"`
	Not                     []LandlordScalarWhereInput `json:"NOT,omitempty"`
}

type PropertyTypeWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type LandlordUpdateManyWithWhereNestedInput struct {
	Where LandlordScalarWhereInput    `json:"where"`
	Data  LandlordUpdateManyDataInput `json:"data"`
}

type PropertyUpdateInput struct {
	Address1              *string                                  `json:"address1,omitempty"`
	Address2              *string                                  `json:"address2,omitempty"`
	Postcode              *string                                  `json:"postcode,omitempty"`
	City                  *string                                  `json:"city,omitempty"`
	Country               *string                                  `json:"country,omitempty"`
	Percentageofownership *int32                                   `json:"percentageofownership,omitempty"`
	Status                *PropertyStatusUpdateOneRequiredInput    `json:"status,omitempty"`
	Type                  *PropertyTypeUpdateOneRequiredInput      `json:"type,omitempty"`
	Purchaseprice         *int32                                   `json:"purchaseprice,omitempty"`
	Currentprice          *int32                                   `json:"currentprice,omitempty"`
	MortgageAmount        *int32                                   `json:"mortgageAmount,omitempty"`
	MortgageInterestRate  *int32                                   `json:"mortgageInterestRate,omitempty"`
	AnnualRentalIncome    *int32                                   `json:"annualRentalIncome,omitempty"`
	Currency              *string                                  `json:"currency,omitempty"`
	Tenants               *TenantUpdateOneWithoutPropertyInput     `json:"tenants,omitempty"`
	Landlords             *LandlordUpdateOneWithoutPropertiesInput `json:"landlords,omitempty"`
}

type LandlordUpdateManyDataInput struct {
	FullName   *string `json:"fullName,omitempty"`
	Email      *string `json:"email,omitempty"`
	Password   *string `json:"password,omitempty"`
	Mobile     *int32  `json:"mobile,omitempty"`
	Dob        *string `json:"dob,omitempty"`
	Occupation *string `json:"occupation,omitempty"`
	Address1   *string `json:"address1,omitempty"`
	Address2   *string `json:"address2,omitempty"`
	Postcode   *string `json:"postcode,omitempty"`
	Country    *string `json:"country,omitempty"`
}

type AgentCreateInput struct {
	BusinessService *string                              `json:"businessService,omitempty"`
	Title           *string                              `json:"title,omitempty"`
	FirstName       string                               `json:"firstName"`
	LastName        *string                              `json:"lastName,omitempty"`
	DisplayName     *string                              `json:"displayName,omitempty"`
	Email           string                               `json:"email"`
	Password        *string                              `json:"password,omitempty"`
	Mobile          *int32                               `json:"mobile,omitempty"`
	Fax             *int32                               `json:"fax,omitempty"`
	Address1        *string                              `json:"address1,omitempty"`
	Address2        *string                              `json:"address2,omitempty"`
	Postcode        string                               `json:"postcode"`
	Country         string                               `json:"country"`
	Website         *string                              `json:"website,omitempty"`
	Clients         *LandlordCreateManyWithoutAgentInput `json:"clients,omitempty"`
}

type AgentUpdateManyMutationInput struct {
	BusinessService *string `json:"businessService,omitempty"`
	Title           *string `json:"title,omitempty"`
	FirstName       *string `json:"firstName,omitempty"`
	LastName        *string `json:"lastName,omitempty"`
	DisplayName     *string `json:"displayName,omitempty"`
	Email           *string `json:"email,omitempty"`
	Password        *string `json:"password,omitempty"`
	Mobile          *int32  `json:"mobile,omitempty"`
	Fax             *int32  `json:"fax,omitempty"`
	Address1        *string `json:"address1,omitempty"`
	Address2        *string `json:"address2,omitempty"`
	Postcode        *string `json:"postcode,omitempty"`
	Country         *string `json:"country,omitempty"`
	Website         *string `json:"website,omitempty"`
}

type PropertyUpsertWithoutTenantsInput struct {
	Update PropertyUpdateWithoutTenantsDataInput `json:"update"`
	Create PropertyCreateWithoutTenantsInput     `json:"create"`
}

type AgentCreateOneWithoutClientsInput struct {
	Create  *AgentCreateWithoutClientsInput `json:"create,omitempty"`
	Connect *AgentWhereUniqueInput          `json:"connect,omitempty"`
}

type LandlordCreateInput struct {
	FullName   string                                   `json:"fullName"`
	Email      string                                   `json:"email"`
	Password   *string                                  `json:"password,omitempty"`
	Mobile     *int32                                   `json:"mobile,omitempty"`
	Dob        *string                                  `json:"dob,omitempty"`
	Occupation *string                                  `json:"occupation,omitempty"`
	Address1   *string                                  `json:"address1,omitempty"`
	Address2   *string                                  `json:"address2,omitempty"`
	Postcode   string                                   `json:"postcode"`
	Country    string                                   `json:"country"`
	Agent      *AgentCreateOneWithoutClientsInput       `json:"agent,omitempty"`
	Properties *PropertyCreateManyWithoutLandlordsInput `json:"properties,omitempty"`
}

type LandlordUpdateInput struct {
	FullName   *string                                  `json:"fullName,omitempty"`
	Email      *string                                  `json:"email,omitempty"`
	Password   *string                                  `json:"password,omitempty"`
	Mobile     *int32                                   `json:"mobile,omitempty"`
	Dob        *string                                  `json:"dob,omitempty"`
	Occupation *string                                  `json:"occupation,omitempty"`
	Address1   *string                                  `json:"address1,omitempty"`
	Address2   *string                                  `json:"address2,omitempty"`
	Postcode   *string                                  `json:"postcode,omitempty"`
	Country    *string                                  `json:"country,omitempty"`
	Agent      *AgentUpdateOneWithoutClientsInput       `json:"agent,omitempty"`
	Properties *PropertyUpdateManyWithoutLandlordsInput `json:"properties,omitempty"`
}

type AgentUpdateOneWithoutClientsInput struct {
	Create     *AgentCreateWithoutClientsInput     `json:"create,omitempty"`
	Update     *AgentUpdateWithoutClientsDataInput `json:"update,omitempty"`
	Upsert     *AgentUpsertWithoutClientsInput     `json:"upsert,omitempty"`
	Delete     *bool                               `json:"delete,omitempty"`
	Disconnect *bool                               `json:"disconnect,omitempty"`
	Connect    *AgentWhereUniqueInput              `json:"connect,omitempty"`
}

type TenantCreateInput struct {
	Title         *string                               `json:"title,omitempty"`
	FirstName     string                                `json:"firstName"`
	MiddleName    *string                               `json:"middleName,omitempty"`
	LastName      *string                               `json:"lastName,omitempty"`
	DisplayName   string                                `json:"displayName"`
	PersonalEmail string                                `json:"personalEmail"`
	WorkEmail     string                                `json:"workEmail"`
	Homenumber    *int32                                `json:"homenumber,omitempty"`
	Mobilenumber  *int32                                `json:"mobilenumber,omitempty"`
	TypeOfLet     TypeOfLetCreateOneInput               `json:"typeOfLet"`
	RentInterval  string                                `json:"rentInterval"`
	Day           *string                               `json:"day,omitempty"`
	StartDate     *string                               `json:"startDate,omitempty"`
	EndDate       *string                               `json:"endDate,omitempty"`
	Notes         *string                               `json:"notes,omitempty"`
	Property      *PropertyCreateOneWithoutTenantsInput `json:"property,omitempty"`
}

type PropertySubscriptionWhereInput struct {
	MutationIn                 []MutationType                   `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                          `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                         `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                         `json:"updatedFields_contains_some,omitempty"`
	Node                       *PropertyWhereInput              `json:"node,omitempty"`
	And                        []PropertySubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []PropertySubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []PropertySubscriptionWhereInput `json:"NOT,omitempty"`
}

type PropertyCreateInput struct {
	Address1              string                                   `json:"address1"`
	Address2              *string                                  `json:"address2,omitempty"`
	Postcode              string                                   `json:"postcode"`
	City                  string                                   `json:"city"`
	Country               string                                   `json:"country"`
	Percentageofownership *int32                                   `json:"percentageofownership,omitempty"`
	Status                PropertyStatusCreateOneInput             `json:"status"`
	Type                  PropertyTypeCreateOneInput               `json:"type"`
	Purchaseprice         *int32                                   `json:"purchaseprice,omitempty"`
	Currentprice          *int32                                   `json:"currentprice,omitempty"`
	MortgageAmount        *int32                                   `json:"mortgageAmount,omitempty"`
	MortgageInterestRate  *int32                                   `json:"mortgageInterestRate,omitempty"`
	AnnualRentalIncome    *int32                                   `json:"annualRentalIncome,omitempty"`
	Currency              *string                                  `json:"currency,omitempty"`
	Tenants               *TenantCreateOneWithoutPropertyInput     `json:"tenants,omitempty"`
	Landlords             *LandlordCreateOneWithoutPropertiesInput `json:"landlords,omitempty"`
}

type LandlordUpsertWithoutPropertiesInput struct {
	Update LandlordUpdateWithoutPropertiesDataInput `json:"update"`
	Create LandlordCreateWithoutPropertiesInput     `json:"create"`
}

type TypeOfLetPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance TypeOfLetPreviousValuesExec) Exec(ctx context.Context) (*TypeOfLetPreviousValues, error) {
	var v TypeOfLetPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TypeOfLetPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TypeOfLetPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance TypeOfLetPreviousValuesExecArray) Exec(ctx context.Context) ([]TypeOfLetPreviousValues, error) {
	var v []TypeOfLetPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TypeOfLetPreviousValues struct {
	ID   string  `json:"id"`
	Name *string `json:"name,omitempty"`
}

type LandlordExec struct {
	exec *prisma.Exec
}

func (instance *LandlordExec) Agent() *AgentExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Agent"},
		"agent",
		[]string{"id", "businessService", "title", "firstName", "lastName", "displayName", "email", "password", "mobile", "fax", "address1", "address2", "postcode", "country", "website"})

	return &AgentExec{ret}
}

type PropertiesParamsExec struct {
	Where   *PropertyWhereInput
	OrderBy *PropertyOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *LandlordExec) Properties(params *PropertiesParamsExec) *PropertyExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"PropertyWhereInput", "PropertyOrderByInput", "Property"},
		"properties",
		[]string{"id", "address1", "address2", "postcode", "city", "country", "percentageofownership", "purchaseprice", "currentprice", "mortgageAmount", "mortgageInterestRate", "annualRentalIncome", "currency"})

	return &PropertyExecArray{ret}
}

func (instance LandlordExec) Exec(ctx context.Context) (*Landlord, error) {
	var v Landlord
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LandlordExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LandlordExecArray struct {
	exec *prisma.Exec
}

func (instance LandlordExecArray) Exec(ctx context.Context) ([]Landlord, error) {
	var v []Landlord
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Landlord struct {
	ID         string  `json:"id"`
	FullName   string  `json:"fullName"`
	Email      string  `json:"email"`
	Password   *string `json:"password,omitempty"`
	Mobile     *int32  `json:"mobile,omitempty"`
	Dob        *string `json:"dob,omitempty"`
	Occupation *string `json:"occupation,omitempty"`
	Address1   *string `json:"address1,omitempty"`
	Address2   *string `json:"address2,omitempty"`
	Postcode   string  `json:"postcode"`
	Country    string  `json:"country"`
}

type LandlordConnectionExec struct {
	exec *prisma.Exec
}

func (instance *LandlordConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *LandlordConnectionExec) Edges() *LandlordEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "LandlordEdge"},
		"edges",
		[]string{"cursor"})

	return &LandlordEdgeExec{ret}
}

func (instance *LandlordConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateLandlord"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance LandlordConnectionExec) Exec(ctx context.Context) (*LandlordConnection, error) {
	var v LandlordConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LandlordConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LandlordConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance LandlordConnectionExecArray) Exec(ctx context.Context) ([]LandlordConnection, error) {
	var v []LandlordConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type LandlordConnection struct {
}

type PropertyStatusExec struct {
	exec *prisma.Exec
}

func (instance PropertyStatusExec) Exec(ctx context.Context) (*PropertyStatus, error) {
	var v PropertyStatus
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PropertyStatusExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PropertyStatusExecArray struct {
	exec *prisma.Exec
}

func (instance PropertyStatusExecArray) Exec(ctx context.Context) ([]PropertyStatus, error) {
	var v []PropertyStatus
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PropertyStatus struct {
	ID     string `json:"id"`
	Status string `json:"status"`
}

type AgentEdgeExec struct {
	exec *prisma.Exec
}

func (instance *AgentEdgeExec) Node() *AgentExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Agent"},
		"node",
		[]string{"id", "businessService", "title", "firstName", "lastName", "displayName", "email", "password", "mobile", "fax", "address1", "address2", "postcode", "country", "website"})

	return &AgentExec{ret}
}

func (instance AgentEdgeExec) Exec(ctx context.Context) (*AgentEdge, error) {
	var v AgentEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AgentEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AgentEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance AgentEdgeExecArray) Exec(ctx context.Context) ([]AgentEdge, error) {
	var v []AgentEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type AgentEdge struct {
	Cursor string `json:"cursor"`
}

type TypeOfLetConnectionExec struct {
	exec *prisma.Exec
}

func (instance *TypeOfLetConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *TypeOfLetConnectionExec) Edges() *TypeOfLetEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "TypeOfLetEdge"},
		"edges",
		[]string{"cursor"})

	return &TypeOfLetEdgeExec{ret}
}

func (instance *TypeOfLetConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateTypeOfLet"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance TypeOfLetConnectionExec) Exec(ctx context.Context) (*TypeOfLetConnection, error) {
	var v TypeOfLetConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TypeOfLetConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TypeOfLetConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance TypeOfLetConnectionExecArray) Exec(ctx context.Context) ([]TypeOfLetConnection, error) {
	var v []TypeOfLetConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TypeOfLetConnection struct {
}

type TenantPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance TenantPreviousValuesExec) Exec(ctx context.Context) (*TenantPreviousValues, error) {
	var v TenantPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TenantPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TenantPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance TenantPreviousValuesExecArray) Exec(ctx context.Context) ([]TenantPreviousValues, error) {
	var v []TenantPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TenantPreviousValues struct {
	ID            string  `json:"id"`
	Title         *string `json:"title,omitempty"`
	FirstName     string  `json:"firstName"`
	MiddleName    *string `json:"middleName,omitempty"`
	LastName      *string `json:"lastName,omitempty"`
	DisplayName   string  `json:"displayName"`
	PersonalEmail string  `json:"personalEmail"`
	WorkEmail     string  `json:"workEmail"`
	Homenumber    *int32  `json:"homenumber,omitempty"`
	Mobilenumber  *int32  `json:"mobilenumber,omitempty"`
	RentInterval  string  `json:"rentInterval"`
	Day           *string `json:"day,omitempty"`
	StartDate     *string `json:"startDate,omitempty"`
	EndDate       *string `json:"endDate,omitempty"`
	Notes         *string `json:"notes,omitempty"`
}

type PageInfoExec struct {
	exec *prisma.Exec
}

func (instance PageInfoExec) Exec(ctx context.Context) (*PageInfo, error) {
	var v PageInfo
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageInfoExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageInfoExecArray struct {
	exec *prisma.Exec
}

func (instance PageInfoExecArray) Exec(ctx context.Context) ([]PageInfo, error) {
	var v []PageInfo
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *string `json:"startCursor,omitempty"`
	EndCursor       *string `json:"endCursor,omitempty"`
}

type TenantConnectionExec struct {
	exec *prisma.Exec
}

func (instance *TenantConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *TenantConnectionExec) Edges() *TenantEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "TenantEdge"},
		"edges",
		[]string{"cursor"})

	return &TenantEdgeExec{ret}
}

func (instance *TenantConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateTenant"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance TenantConnectionExec) Exec(ctx context.Context) (*TenantConnection, error) {
	var v TenantConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TenantConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TenantConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance TenantConnectionExecArray) Exec(ctx context.Context) ([]TenantConnection, error) {
	var v []TenantConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TenantConnection struct {
}

type TenantSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *TenantSubscriptionPayloadExec) Node() *TenantExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Tenant"},
		"node",
		[]string{"id", "title", "firstName", "middleName", "lastName", "displayName", "personalEmail", "workEmail", "homenumber", "mobilenumber", "rentInterval", "day", "startDate", "endDate", "notes"})

	return &TenantExec{ret}
}

func (instance *TenantSubscriptionPayloadExec) PreviousValues() *TenantPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "TenantPreviousValues"},
		"previousValues",
		[]string{"id", "title", "firstName", "middleName", "lastName", "displayName", "personalEmail", "workEmail", "homenumber", "mobilenumber", "rentInterval", "day", "startDate", "endDate", "notes"})

	return &TenantPreviousValuesExec{ret}
}

func (instance TenantSubscriptionPayloadExec) Exec(ctx context.Context) (*TenantSubscriptionPayload, error) {
	var v TenantSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TenantSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TenantSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance TenantSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]TenantSubscriptionPayload, error) {
	var v []TenantSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TenantSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type AgentSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *AgentSubscriptionPayloadExec) Node() *AgentExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Agent"},
		"node",
		[]string{"id", "businessService", "title", "firstName", "lastName", "displayName", "email", "password", "mobile", "fax", "address1", "address2", "postcode", "country", "website"})

	return &AgentExec{ret}
}

func (instance *AgentSubscriptionPayloadExec) PreviousValues() *AgentPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AgentPreviousValues"},
		"previousValues",
		[]string{"id", "businessService", "title", "firstName", "lastName", "displayName", "email", "password", "mobile", "fax", "address1", "address2", "postcode", "country", "website"})

	return &AgentPreviousValuesExec{ret}
}

func (instance AgentSubscriptionPayloadExec) Exec(ctx context.Context) (*AgentSubscriptionPayload, error) {
	var v AgentSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AgentSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AgentSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance AgentSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]AgentSubscriptionPayload, error) {
	var v []AgentSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type AgentSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type PropertyTypeConnectionExec struct {
	exec *prisma.Exec
}

func (instance *PropertyTypeConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *PropertyTypeConnectionExec) Edges() *PropertyTypeEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PropertyTypeEdge"},
		"edges",
		[]string{"cursor"})

	return &PropertyTypeEdgeExec{ret}
}

func (instance *PropertyTypeConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregatePropertyType"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance PropertyTypeConnectionExec) Exec(ctx context.Context) (*PropertyTypeConnection, error) {
	var v PropertyTypeConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PropertyTypeConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PropertyTypeConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance PropertyTypeConnectionExecArray) Exec(ctx context.Context) ([]PropertyTypeConnection, error) {
	var v []PropertyTypeConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PropertyTypeConnection struct {
}

type AgentPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance AgentPreviousValuesExec) Exec(ctx context.Context) (*AgentPreviousValues, error) {
	var v AgentPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AgentPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AgentPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance AgentPreviousValuesExecArray) Exec(ctx context.Context) ([]AgentPreviousValues, error) {
	var v []AgentPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type AgentPreviousValues struct {
	ID              string  `json:"id"`
	BusinessService *string `json:"businessService,omitempty"`
	Title           *string `json:"title,omitempty"`
	FirstName       string  `json:"firstName"`
	LastName        *string `json:"lastName,omitempty"`
	DisplayName     *string `json:"displayName,omitempty"`
	Email           string  `json:"email"`
	Password        *string `json:"password,omitempty"`
	Mobile          *int32  `json:"mobile,omitempty"`
	Fax             *int32  `json:"fax,omitempty"`
	Address1        *string `json:"address1,omitempty"`
	Address2        *string `json:"address2,omitempty"`
	Postcode        string  `json:"postcode"`
	Country         string  `json:"country"`
	Website         *string `json:"website,omitempty"`
}

type PropertyStatusEdgeExec struct {
	exec *prisma.Exec
}

func (instance *PropertyStatusEdgeExec) Node() *PropertyStatusExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PropertyStatus"},
		"node",
		[]string{"id", "status"})

	return &PropertyStatusExec{ret}
}

func (instance PropertyStatusEdgeExec) Exec(ctx context.Context) (*PropertyStatusEdge, error) {
	var v PropertyStatusEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PropertyStatusEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PropertyStatusEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance PropertyStatusEdgeExecArray) Exec(ctx context.Context) ([]PropertyStatusEdge, error) {
	var v []PropertyStatusEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PropertyStatusEdge struct {
	Cursor string `json:"cursor"`
}

type AgentConnectionExec struct {
	exec *prisma.Exec
}

func (instance *AgentConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *AgentConnectionExec) Edges() *AgentEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AgentEdge"},
		"edges",
		[]string{"cursor"})

	return &AgentEdgeExec{ret}
}

func (instance *AgentConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateAgent"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance AgentConnectionExec) Exec(ctx context.Context) (*AgentConnection, error) {
	var v AgentConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AgentConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AgentConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance AgentConnectionExecArray) Exec(ctx context.Context) ([]AgentConnection, error) {
	var v []AgentConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type AgentConnection struct {
}

type PropertyExec struct {
	exec *prisma.Exec
}

func (instance *PropertyExec) Status() *PropertyStatusExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PropertyStatus"},
		"status",
		[]string{"id", "status"})

	return &PropertyStatusExec{ret}
}

func (instance *PropertyExec) Type() *PropertyTypeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PropertyType"},
		"type",
		[]string{"id", "type"})

	return &PropertyTypeExec{ret}
}

func (instance *PropertyExec) Tenants() *TenantExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Tenant"},
		"tenants",
		[]string{"id", "title", "firstName", "middleName", "lastName", "displayName", "personalEmail", "workEmail", "homenumber", "mobilenumber", "rentInterval", "day", "startDate", "endDate", "notes"})

	return &TenantExec{ret}
}

func (instance *PropertyExec) Landlords() *LandlordExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Landlord"},
		"landlords",
		[]string{"id", "fullName", "email", "password", "mobile", "dob", "occupation", "address1", "address2", "postcode", "country"})

	return &LandlordExec{ret}
}

func (instance PropertyExec) Exec(ctx context.Context) (*Property, error) {
	var v Property
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PropertyExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PropertyExecArray struct {
	exec *prisma.Exec
}

func (instance PropertyExecArray) Exec(ctx context.Context) ([]Property, error) {
	var v []Property
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Property struct {
	ID                    string  `json:"id"`
	Address1              string  `json:"address1"`
	Address2              *string `json:"address2,omitempty"`
	Postcode              string  `json:"postcode"`
	City                  string  `json:"city"`
	Country               string  `json:"country"`
	Percentageofownership *int32  `json:"percentageofownership,omitempty"`
	Purchaseprice         *int32  `json:"purchaseprice,omitempty"`
	Currentprice          *int32  `json:"currentprice,omitempty"`
	MortgageAmount        *int32  `json:"mortgageAmount,omitempty"`
	MortgageInterestRate  *int32  `json:"mortgageInterestRate,omitempty"`
	AnnualRentalIncome    *int32  `json:"annualRentalIncome,omitempty"`
	Currency              *string `json:"currency,omitempty"`
}

type LandlordSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *LandlordSubscriptionPayloadExec) Node() *LandlordExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Landlord"},
		"node",
		[]string{"id", "fullName", "email", "password", "mobile", "dob", "occupation", "address1", "address2", "postcode", "country"})

	return &LandlordExec{ret}
}

func (instance *LandlordSubscriptionPayloadExec) PreviousValues() *LandlordPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "LandlordPreviousValues"},
		"previousValues",
		[]string{"id", "fullName", "email", "password", "mobile", "dob", "occupation", "address1", "address2", "postcode", "country"})

	return &LandlordPreviousValuesExec{ret}
}

func (instance LandlordSubscriptionPayloadExec) Exec(ctx context.Context) (*LandlordSubscriptionPayload, error) {
	var v LandlordSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LandlordSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LandlordSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance LandlordSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]LandlordSubscriptionPayload, error) {
	var v []LandlordSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type LandlordSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type PropertyEdgeExec struct {
	exec *prisma.Exec
}

func (instance *PropertyEdgeExec) Node() *PropertyExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Property"},
		"node",
		[]string{"id", "address1", "address2", "postcode", "city", "country", "percentageofownership", "purchaseprice", "currentprice", "mortgageAmount", "mortgageInterestRate", "annualRentalIncome", "currency"})

	return &PropertyExec{ret}
}

func (instance PropertyEdgeExec) Exec(ctx context.Context) (*PropertyEdge, error) {
	var v PropertyEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PropertyEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PropertyEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance PropertyEdgeExecArray) Exec(ctx context.Context) ([]PropertyEdge, error) {
	var v []PropertyEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PropertyEdge struct {
	Cursor string `json:"cursor"`
}

type LandlordPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance LandlordPreviousValuesExec) Exec(ctx context.Context) (*LandlordPreviousValues, error) {
	var v LandlordPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LandlordPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LandlordPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance LandlordPreviousValuesExecArray) Exec(ctx context.Context) ([]LandlordPreviousValues, error) {
	var v []LandlordPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type LandlordPreviousValues struct {
	ID         string  `json:"id"`
	FullName   string  `json:"fullName"`
	Email      string  `json:"email"`
	Password   *string `json:"password,omitempty"`
	Mobile     *int32  `json:"mobile,omitempty"`
	Dob        *string `json:"dob,omitempty"`
	Occupation *string `json:"occupation,omitempty"`
	Address1   *string `json:"address1,omitempty"`
	Address2   *string `json:"address2,omitempty"`
	Postcode   string  `json:"postcode"`
	Country    string  `json:"country"`
}

type TypeOfLetExec struct {
	exec *prisma.Exec
}

func (instance TypeOfLetExec) Exec(ctx context.Context) (*TypeOfLet, error) {
	var v TypeOfLet
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TypeOfLetExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TypeOfLetExecArray struct {
	exec *prisma.Exec
}

func (instance TypeOfLetExecArray) Exec(ctx context.Context) ([]TypeOfLet, error) {
	var v []TypeOfLet
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TypeOfLet struct {
	ID   string  `json:"id"`
	Name *string `json:"name,omitempty"`
}

type TypeOfLetEdgeExec struct {
	exec *prisma.Exec
}

func (instance *TypeOfLetEdgeExec) Node() *TypeOfLetExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "TypeOfLet"},
		"node",
		[]string{"id", "name"})

	return &TypeOfLetExec{ret}
}

func (instance TypeOfLetEdgeExec) Exec(ctx context.Context) (*TypeOfLetEdge, error) {
	var v TypeOfLetEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TypeOfLetEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TypeOfLetEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance TypeOfLetEdgeExecArray) Exec(ctx context.Context) ([]TypeOfLetEdge, error) {
	var v []TypeOfLetEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TypeOfLetEdge struct {
	Cursor string `json:"cursor"`
}

type PropertySubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *PropertySubscriptionPayloadExec) Node() *PropertyExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Property"},
		"node",
		[]string{"id", "address1", "address2", "postcode", "city", "country", "percentageofownership", "purchaseprice", "currentprice", "mortgageAmount", "mortgageInterestRate", "annualRentalIncome", "currency"})

	return &PropertyExec{ret}
}

func (instance *PropertySubscriptionPayloadExec) PreviousValues() *PropertyPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PropertyPreviousValues"},
		"previousValues",
		[]string{"id", "address1", "address2", "postcode", "city", "country", "percentageofownership", "purchaseprice", "currentprice", "mortgageAmount", "mortgageInterestRate", "annualRentalIncome", "currency"})

	return &PropertyPreviousValuesExec{ret}
}

func (instance PropertySubscriptionPayloadExec) Exec(ctx context.Context) (*PropertySubscriptionPayload, error) {
	var v PropertySubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PropertySubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PropertySubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance PropertySubscriptionPayloadExecArray) Exec(ctx context.Context) ([]PropertySubscriptionPayload, error) {
	var v []PropertySubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PropertySubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type TenantEdgeExec struct {
	exec *prisma.Exec
}

func (instance *TenantEdgeExec) Node() *TenantExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Tenant"},
		"node",
		[]string{"id", "title", "firstName", "middleName", "lastName", "displayName", "personalEmail", "workEmail", "homenumber", "mobilenumber", "rentInterval", "day", "startDate", "endDate", "notes"})

	return &TenantExec{ret}
}

func (instance TenantEdgeExec) Exec(ctx context.Context) (*TenantEdge, error) {
	var v TenantEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TenantEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TenantEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance TenantEdgeExecArray) Exec(ctx context.Context) ([]TenantEdge, error) {
	var v []TenantEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TenantEdge struct {
	Cursor string `json:"cursor"`
}

type PropertyPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance PropertyPreviousValuesExec) Exec(ctx context.Context) (*PropertyPreviousValues, error) {
	var v PropertyPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PropertyPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PropertyPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance PropertyPreviousValuesExecArray) Exec(ctx context.Context) ([]PropertyPreviousValues, error) {
	var v []PropertyPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PropertyPreviousValues struct {
	ID                    string  `json:"id"`
	Address1              string  `json:"address1"`
	Address2              *string `json:"address2,omitempty"`
	Postcode              string  `json:"postcode"`
	City                  string  `json:"city"`
	Country               string  `json:"country"`
	Percentageofownership *int32  `json:"percentageofownership,omitempty"`
	Purchaseprice         *int32  `json:"purchaseprice,omitempty"`
	Currentprice          *int32  `json:"currentprice,omitempty"`
	MortgageAmount        *int32  `json:"mortgageAmount,omitempty"`
	MortgageInterestRate  *int32  `json:"mortgageInterestRate,omitempty"`
	AnnualRentalIncome    *int32  `json:"annualRentalIncome,omitempty"`
	Currency              *string `json:"currency,omitempty"`
}

type PropertyTypeEdgeExec struct {
	exec *prisma.Exec
}

func (instance *PropertyTypeEdgeExec) Node() *PropertyTypeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PropertyType"},
		"node",
		[]string{"id", "type"})

	return &PropertyTypeExec{ret}
}

func (instance PropertyTypeEdgeExec) Exec(ctx context.Context) (*PropertyTypeEdge, error) {
	var v PropertyTypeEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PropertyTypeEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PropertyTypeEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance PropertyTypeEdgeExecArray) Exec(ctx context.Context) ([]PropertyTypeEdge, error) {
	var v []PropertyTypeEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PropertyTypeEdge struct {
	Cursor string `json:"cursor"`
}

type TenantExec struct {
	exec *prisma.Exec
}

func (instance *TenantExec) TypeOfLet() *TypeOfLetExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "TypeOfLet"},
		"typeOfLet",
		[]string{"id", "name"})

	return &TypeOfLetExec{ret}
}

func (instance *TenantExec) Property() *PropertyExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Property"},
		"property",
		[]string{"id", "address1", "address2", "postcode", "city", "country", "percentageofownership", "purchaseprice", "currentprice", "mortgageAmount", "mortgageInterestRate", "annualRentalIncome", "currency"})

	return &PropertyExec{ret}
}

func (instance TenantExec) Exec(ctx context.Context) (*Tenant, error) {
	var v Tenant
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TenantExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TenantExecArray struct {
	exec *prisma.Exec
}

func (instance TenantExecArray) Exec(ctx context.Context) ([]Tenant, error) {
	var v []Tenant
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Tenant struct {
	ID            string  `json:"id"`
	Title         *string `json:"title,omitempty"`
	FirstName     string  `json:"firstName"`
	MiddleName    *string `json:"middleName,omitempty"`
	LastName      *string `json:"lastName,omitempty"`
	DisplayName   string  `json:"displayName"`
	PersonalEmail string  `json:"personalEmail"`
	WorkEmail     string  `json:"workEmail"`
	Homenumber    *int32  `json:"homenumber,omitempty"`
	Mobilenumber  *int32  `json:"mobilenumber,omitempty"`
	RentInterval  string  `json:"rentInterval"`
	Day           *string `json:"day,omitempty"`
	StartDate     *string `json:"startDate,omitempty"`
	EndDate       *string `json:"endDate,omitempty"`
	Notes         *string `json:"notes,omitempty"`
}

type PropertyStatusConnectionExec struct {
	exec *prisma.Exec
}

func (instance *PropertyStatusConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *PropertyStatusConnectionExec) Edges() *PropertyStatusEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PropertyStatusEdge"},
		"edges",
		[]string{"cursor"})

	return &PropertyStatusEdgeExec{ret}
}

func (instance *PropertyStatusConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregatePropertyStatus"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance PropertyStatusConnectionExec) Exec(ctx context.Context) (*PropertyStatusConnection, error) {
	var v PropertyStatusConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PropertyStatusConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PropertyStatusConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance PropertyStatusConnectionExecArray) Exec(ctx context.Context) ([]PropertyStatusConnection, error) {
	var v []PropertyStatusConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PropertyStatusConnection struct {
}

type PropertyStatusSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *PropertyStatusSubscriptionPayloadExec) Node() *PropertyStatusExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PropertyStatus"},
		"node",
		[]string{"id", "status"})

	return &PropertyStatusExec{ret}
}

func (instance *PropertyStatusSubscriptionPayloadExec) PreviousValues() *PropertyStatusPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PropertyStatusPreviousValues"},
		"previousValues",
		[]string{"id", "status"})

	return &PropertyStatusPreviousValuesExec{ret}
}

func (instance PropertyStatusSubscriptionPayloadExec) Exec(ctx context.Context) (*PropertyStatusSubscriptionPayload, error) {
	var v PropertyStatusSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PropertyStatusSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PropertyStatusSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance PropertyStatusSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]PropertyStatusSubscriptionPayload, error) {
	var v []PropertyStatusSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PropertyStatusSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type PropertyConnectionExec struct {
	exec *prisma.Exec
}

func (instance *PropertyConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *PropertyConnectionExec) Edges() *PropertyEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PropertyEdge"},
		"edges",
		[]string{"cursor"})

	return &PropertyEdgeExec{ret}
}

func (instance *PropertyConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateProperty"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance PropertyConnectionExec) Exec(ctx context.Context) (*PropertyConnection, error) {
	var v PropertyConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PropertyConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PropertyConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance PropertyConnectionExecArray) Exec(ctx context.Context) ([]PropertyConnection, error) {
	var v []PropertyConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PropertyConnection struct {
}

type AgentExec struct {
	exec *prisma.Exec
}

type ClientsParamsExec struct {
	Where   *LandlordWhereInput
	OrderBy *LandlordOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *AgentExec) Clients(params *ClientsParamsExec) *LandlordExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"LandlordWhereInput", "LandlordOrderByInput", "Landlord"},
		"clients",
		[]string{"id", "fullName", "email", "password", "mobile", "dob", "occupation", "address1", "address2", "postcode", "country"})

	return &LandlordExecArray{ret}
}

func (instance AgentExec) Exec(ctx context.Context) (*Agent, error) {
	var v Agent
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AgentExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AgentExecArray struct {
	exec *prisma.Exec
}

func (instance AgentExecArray) Exec(ctx context.Context) ([]Agent, error) {
	var v []Agent
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Agent struct {
	ID              string  `json:"id"`
	BusinessService *string `json:"businessService,omitempty"`
	Title           *string `json:"title,omitempty"`
	FirstName       string  `json:"firstName"`
	LastName        *string `json:"lastName,omitempty"`
	DisplayName     *string `json:"displayName,omitempty"`
	Email           string  `json:"email"`
	Password        *string `json:"password,omitempty"`
	Mobile          *int32  `json:"mobile,omitempty"`
	Fax             *int32  `json:"fax,omitempty"`
	Address1        *string `json:"address1,omitempty"`
	Address2        *string `json:"address2,omitempty"`
	Postcode        string  `json:"postcode"`
	Country         string  `json:"country"`
	Website         *string `json:"website,omitempty"`
}

type PropertyTypePreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance PropertyTypePreviousValuesExec) Exec(ctx context.Context) (*PropertyTypePreviousValues, error) {
	var v PropertyTypePreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PropertyTypePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PropertyTypePreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance PropertyTypePreviousValuesExecArray) Exec(ctx context.Context) ([]PropertyTypePreviousValues, error) {
	var v []PropertyTypePreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PropertyTypePreviousValues struct {
	ID   string `json:"id"`
	Type string `json:"type"`
}

type PropertyTypeSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *PropertyTypeSubscriptionPayloadExec) Node() *PropertyTypeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PropertyType"},
		"node",
		[]string{"id", "type"})

	return &PropertyTypeExec{ret}
}

func (instance *PropertyTypeSubscriptionPayloadExec) PreviousValues() *PropertyTypePreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PropertyTypePreviousValues"},
		"previousValues",
		[]string{"id", "type"})

	return &PropertyTypePreviousValuesExec{ret}
}

func (instance PropertyTypeSubscriptionPayloadExec) Exec(ctx context.Context) (*PropertyTypeSubscriptionPayload, error) {
	var v PropertyTypeSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PropertyTypeSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PropertyTypeSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance PropertyTypeSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]PropertyTypeSubscriptionPayload, error) {
	var v []PropertyTypeSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PropertyTypeSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type PropertyTypeExec struct {
	exec *prisma.Exec
}

func (instance PropertyTypeExec) Exec(ctx context.Context) (*PropertyType, error) {
	var v PropertyType
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PropertyTypeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PropertyTypeExecArray struct {
	exec *prisma.Exec
}

func (instance PropertyTypeExecArray) Exec(ctx context.Context) ([]PropertyType, error) {
	var v []PropertyType
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PropertyType struct {
	ID   string `json:"id"`
	Type string `json:"type"`
}

type PropertyStatusPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance PropertyStatusPreviousValuesExec) Exec(ctx context.Context) (*PropertyStatusPreviousValues, error) {
	var v PropertyStatusPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PropertyStatusPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PropertyStatusPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance PropertyStatusPreviousValuesExecArray) Exec(ctx context.Context) ([]PropertyStatusPreviousValues, error) {
	var v []PropertyStatusPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PropertyStatusPreviousValues struct {
	ID     string `json:"id"`
	Status string `json:"status"`
}

type TypeOfLetSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *TypeOfLetSubscriptionPayloadExec) Node() *TypeOfLetExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "TypeOfLet"},
		"node",
		[]string{"id", "name"})

	return &TypeOfLetExec{ret}
}

func (instance *TypeOfLetSubscriptionPayloadExec) PreviousValues() *TypeOfLetPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "TypeOfLetPreviousValues"},
		"previousValues",
		[]string{"id", "name"})

	return &TypeOfLetPreviousValuesExec{ret}
}

func (instance TypeOfLetSubscriptionPayloadExec) Exec(ctx context.Context) (*TypeOfLetSubscriptionPayload, error) {
	var v TypeOfLetSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TypeOfLetSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TypeOfLetSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance TypeOfLetSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]TypeOfLetSubscriptionPayload, error) {
	var v []TypeOfLetSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TypeOfLetSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type LandlordEdgeExec struct {
	exec *prisma.Exec
}

func (instance *LandlordEdgeExec) Node() *LandlordExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Landlord"},
		"node",
		[]string{"id", "fullName", "email", "password", "mobile", "dob", "occupation", "address1", "address2", "postcode", "country"})

	return &LandlordExec{ret}
}

func (instance LandlordEdgeExec) Exec(ctx context.Context) (*LandlordEdge, error) {
	var v LandlordEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LandlordEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LandlordEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance LandlordEdgeExecArray) Exec(ctx context.Context) ([]LandlordEdge, error) {
	var v []LandlordEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type LandlordEdge struct {
	Cursor string `json:"cursor"`
}
